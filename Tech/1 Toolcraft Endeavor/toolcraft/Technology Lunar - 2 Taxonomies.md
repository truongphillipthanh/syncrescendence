# Comprehensive Taxonomies: Operational Typologies

## I. Unified Layer Architecture (Reconciled Framework)

### The Three-View Reconciliation

Rather than competing layer systems, we recognize three complementary perspectives on the same underlying reality:

**Constitutional View (Capability Architecture)**:
- Describes what computational capabilities exist at each level
- Organized by fundamental constraints and possibilities
- Answers: "What can be done at this level?"

**Frequency View (Interaction Cadence)**:
- Describes how often humans engage with each level
- Organized by usage patterns and access frequency
- Answers: "How often do I interact with this?"

**Cognitive View (Orchestration Pattern)**:
- Describes how intelligence mediates at each level
- Organized by displacement mechanism and intent architecture
- Answers: "How does AI enable this?"

### Constitutional Layers (Capability Architecture)

**Layer C0: Physical Substrate**
- Material and energetic foundation
- Atomic, molecular, electromagnetic phenomena
- Constraints: Physics, thermodynamics, materials science
- Platform manifestation: Device hardware, sensors, actuators, energy systems

**Layer C1: Transduction Interface**
- Bidirectional signal conversion
- Sensors (physical → digital) and actuators (digital → physical)
- Constraints: Bandwidth, fidelity, latency
- Platform manifestation: Touchscreens, cameras, speakers, haptics, displays

**Layer C2: Perceptual Surface**
- Meaningful sensory experiences
- Visual, auditory, haptic presentation
- Constraints: Human perception limits, attention capacity
- Platform manifestation: UI frameworks, rendering engines, audio systems

**Layer C3: Interaction Grammar**
- Structured vocabulary of actions
- Gestures, commands, natural language
- Constraints: Learnability, expressiveness, recognition accuracy
- Platform manifestation: Input handlers, gesture recognition, voice interfaces

**Layer C4: Choreographic Flows**
- Temporal orchestration of interactions
- Workflows, navigation, state management
- Constraints: Working memory, task complexity
- Platform manifestation: Window managers, workflow engines, automation systems

**Layer C5: Cognitive Convergence**
- Human-AI hybrid intelligence
- Augmentation, collaboration, delegation
- Constraints: Trust calibration, alignment, transparency
- Platform manifestation: AI assistants, copilots, agents, intelligence routing

**Layer C6: Primitive Composition**
- Feature extraction and recombination
- Tool decomposition, bespoke generation
- Constraints: Primitive catalog quality, composition complexity
- Platform manifestation: Feature libraries, code generation, just-in-time tools

**Layer C7: Meta-Orchestration**
- System-level reflexivity and evolution
- Self-observation, pattern recognition, optimization
- Constraints: Observation quality, learning algorithms, approval mechanisms
- Platform manifestation: Usage analytics, apparatus recognition, routing intelligence

### Frequency Layers (Interaction Cadence)

**Layer F0: Subconscious (Continuous, unnoticed)**
- Always-on sensing, ambient monitoring
- Examples: Device sensors, background sync, system maintenance
- User engagement: None—operates without awareness
- Displacement: Ambient intelligence anticipates needs

**Layer F1: Interface Actions (Multiple per minute)**
- Micro-interactions, navigation, input gestures
- Examples: Scrolling, clicking, typing, swiping
- User engagement: Continuous during active use
- Displacement: Intelligent defaults, predictive UI

**Layer F2: Task Execution (Multiple per hour)**
- Discrete work operations, tool invocations
- Examples: Send email, create document, run analysis
- User engagement: Frequent during work sessions
- Displacement: Automated workflows, copilot assistance

**Layer F3: Workflow Orchestration (Multiple per day)**
- Multi-step processes, project activities
- Examples: Complete analysis, write report, conduct research
- User engagement: Several times per work day
- Displacement: Delegation to agents, workflow automation

**Layer F4: Context Switching (Multiple per week)**
- Project changes, role transitions, major mode shifts
- Examples: Switch from writing to analysis, start new project
- User engagement: Weekly or multiple times weekly
- Displacement: Context preservation, seamless transitions

**Layer F5: Configuration (Monthly)**
- Tool selection, workspace setup, preference adjustments
- Examples: Install new tool, reorganize workspace, update settings
- User engagement: Periodic optimization
- Displacement: Intelligent configuration, automatic optimization

**Layer F6: Strategic Review (Quarterly)**
- System architecture evaluation, major changes
- Examples: Tool audit, workflow redesign, technology adoption
- User engagement: Rare but impactful
- Displacement: Meta-orchestration suggestions, pattern insights

**Layer F7: Meta-Evolution (Annually)**
- Paradigm shifts, fundamental rethinking
- Examples: New work mode, platform transition, framework update
- User engagement: Very rare, transformative
- Displacement: Paradigm detection, evolution proposals

### Cognitive Orchestration Layers (Intelligence Mediation)

**Layer CO0: Physical Automation**
- Robotic control, device manipulation
- Examples: 3D printing, robot arms, smart home actuators
- Displacement: Physical tasks automated

**Layer CO1: Perceptual Processing**
- Sensory data interpretation
- Examples: Image recognition, speech-to-text, gesture detection
- Displacement: Removes need for explicit commands

**Layer CO2: Operation Completion**
- Single discrete work operations
- Autocomplete, suggestions, template application
- Examples: Predictive text, code completion, smart compose
- Displacement: Reduces mechanical execution burden

**Layer CO3: Workflow Orchestration**
- Coordination across multi-step processes
- State management, error handling, optimization
- Examples: Build pipelines, data workflows, approval chains
- Displacement: Automates coordination overhead

**Layer CO4: Context Synthesis**
- Integrating information across sources and time
- Research, summarization, knowledge management
- Examples: RAG systems, knowledge graphs, research agents
- Displacement: Eliminates manual information gathering and synthesis

**Layer CO5: Capability Routing**
- Intelligent selection of tools and primitives
- Intent → optimal primitive composition
- Examples: Smart tool selection, automated workflow assembly
- Displacement: Removes need to know which tool to use

**Layer CO6: Apparatus Crystallization**
- Detection and formalization of emergent patterns
- Usage observation → workflow recognition → pattern naming
- Examples: Detecting repeated tool sequences, suggesting apparatus creation
- Displacement: Automatic workflow optimization from observation

**Layer CO7: Meta-Orchestration**
- System-level reflexivity and evolution
- Observing orchestration itself, optimizing the optimizer
- Examples: Pattern detection across usage, primitive catalog curation, routing intelligence improvement, silent component detection
- Displacement: System improves itself without manual intervention

**Layer CO8: Strategic Intelligence**
- High-level planning and decision support
- Scenario modeling, trend analysis, strategic synthesis
- Examples: Business intelligence, competitive analysis, portfolio optimization
- Displacement: Augments strategic thinking with comprehensive analysis

---

## II. Memory Primitive Taxonomy

Memory primitives form the foundation for persistent, learning-capable AI systems. These are not application features but fundamental architectural components.

### Memory Tier Classification

**Tier 1: Working Memory (O.STM - Short-term Memory)**
- **Function**: Immediate task context, active processing
- **Capacity**: Limited (context window constrained)
- **Access latency**: Very fast (<10ms)
- **Persistence**: Volatile (session-scoped)
- **Implementation**: In-context prompt window, temporary buffers
- **Use cases**: Conversation continuity, current task state, reasoning workspace
- **Analogy**: Human short-term memory, active thoughts

**Tier 2: Episodic Memory (O.DP - Data Persistence)**
- **Function**: Specific past experiences and events
- **Capacity**: Large (millions of interactions)
- **Access latency**: Medium (100-500ms)
- **Persistence**: Durable (long-term storage)
- **Implementation**: Structured event logs, interaction histories, experience databases
- **Use cases**: Learning from past failures, case-based reasoning, historical context
- **Analogy**: Human autobiographical memory, specific remembered events

**Tier 3: Semantic Memory (O.DP + O.MOD)**
- **Function**: General factual knowledge and concepts
- **Capacity**: Massive (unlimited external knowledge)
- **Access latency**: Fast (50-200ms with vector search)
- **Persistence**: Durable with updates
- **Implementation**: Vector databases with embeddings, knowledge graphs, fact stores
- **Use cases**: Question answering, knowledge synthesis, domain expertise
- **Analogy**: Human semantic memory, general knowledge

**Tier 4: Procedural Memory (O.FN - Function Objects)**
- **Function**: Learned skills and automated workflows
- **Capacity**: Medium (hundreds to thousands of procedures)
- **Access latency**: Very fast (<10ms direct invocation)
- **Persistence**: Durable with versioning
- **Implementation**: Cached workflows, function libraries, trained skill models
- **Use cases**: Routine operations, optimized patterns, automatic execution
- **Analogy**: Human muscle memory, practiced skills

**Tier 5: Prospective Memory (O.WF - Workflow Objects)**
- **Function**: Future intentions and scheduled actions
- **Capacity**: Medium (thousands of pending items)
- **Access latency**: Event/time-triggered
- **Persistence**: Durable until completion
- **Implementation**: Task queues, calendar integrations, reminder systems
- **Use cases**: Follow-up actions, scheduled tasks, future commitments
- **Analogy**: Human remembering to do something later, mental to-do list

### Memory Operation Primitives

**Capture Primitives**:
- **Selective Recording**: Filter by importance, novelty, utility
- **Multi-modal Capture**: Text, images, structured data, interaction logs
- **Context Enrichment**: Add metadata, embeddings, relationships
- **Real-time vs. Batch**: Immediate capture vs. idle-time processing

**Retrieval Primitives**:
- **Similarity Search** (O.FN): Vector embeddings find semantically related memories
- **Temporal Proximity** (O.FN): Recent memories weighted higher
- **Contextual Relevance** (O.FN): Current task determines what's retrieved
- **Multi-stage Retrieval** (O.WF): Broad search → relevance ranking → detail fetch
- **Hybrid Strategies** (O.WF): Combine vector similarity with keyword, metadata, graph traversal

**Decay Primitives**:
- **Summarization Triggers** (O.FN): Periodically condense old memories
- **Forgetting Policies** (O.POL): Prune low-utility memories
- **Priority Weighting** (O.FN): Preserve frequently-accessed or high-value memories
- **Sleep-time Reorganization** (O.WF): Async background processing during idle
  - Consolidate related memories
  - Update semantic indices
  - Prune low-value entries
  - Reorganize access patterns

**Transmission Primitives**:
- **State Transfer Protocols** (O.SVC): Standard formats for memory handoffs
- **Context Serialization** (O.FN): Package relevant memories for new threads
- **Hierarchical Summarization** (O.FN): Multi-level abstractions (detail → summary → gist)
- **Selective Synchronization** (O.WF): Only relevant subsets transmitted

### Memory Architecture Patterns

**Pattern: Hierarchical Recall**
- **Object composition**: O.STM (working) → O.DP (semantic) → O.DP (episodic) → Research
- **Flow**: Query working memory first (fast), fall back to semantic (medium), then episodic (slow), finally external research
- **Platform**: Universal
- **Use case**: Question answering with graceful degradation

**Pattern: Experience Replay Learning**
- **Object composition**: O.DP (episodic logs) → O.FN (pattern extraction) → O.DP (semantic knowledge) → O.FN (procedural skills)
- **Flow**: Task execution → log to episodic → periodic review → extract patterns → distill to semantic → encode high-frequency as procedural
- **Platform**: Universal
- **Use case**: Continuous improvement from past experiences

**Pattern: Context Assembly**
- **Object composition**: O.FN (relevance scoring) → O.DP (multiple memory tiers) → O.STM (working memory)
- **Flow**: New task → retrieve relevant semantic knowledge → find related past episodes → load active procedural skills → assemble into working memory → execute with full historical awareness
- **Platform**: Universal
- **Use case**: Preparing for task with comprehensive context

**Pattern: Dynamic Memory Networks (A-MEM)**
- **Object composition**: O.DP (memory graph) + O.MOD (embedding model) + O.FN (link generation)
- **Flow**: New experience → generate comprehensive note with embeddings → analyze historical memories → establish links → evolve existing memory attributes → self-organizing network
- **Platform**: Universal
- **Use case**: Self-organizing knowledge networks without fixed schemas

### Memory Platform Considerations

**Desktop**: Large-scale memory operations, complex queries, visualization
**Mobile**: Quick memory access, voice-driven queries, opportunistic capture
**XR**: Spatial memory visualization, immersive recall, gesture-based navigation
**Ambient**: Continuous background capture, proactive memory surfacing
**CLI**: Scriptable memory operations, batch processing, automation

---

## III. Orchestration Primitive Taxonomy

Orchestration primitives enable coordination of multiple agents, tools, and workflows into coherent systems.

### Coordination Pattern Primitives

**Sequential Coordination (O.WF)**
- **Structure**: Linear handoff chain—Agent A → Agent B → Agent C
- **Object type**: Workflow with ordered steps
- **Characteristics**: Deterministic, simple debugging, no parallelism
- **When to use**: Well-defined pipeline with clear stage boundaries
- **Example**: Research → draft → edit → publish
- **Platform**: Universal

**Concurrent Execution (O.WF)**
- **Structure**: Parallel independent agents → aggregation step
- **Object type**: Workflow with parallel branches
- **Characteristics**: Fastest execution, requires independent subtasks, aggregation complexity
- **When to use**: Tasks are independent and can run simultaneously
- **Example**: Multi-company financial analysis—one agent per company, results combined
- **Platform**: Desktop, Cloud (requires sufficient compute resources)

**Group Chat Coordination (O.AGT + O.SVC)**
- **Structure**: Shared conversation thread managed by chat manager
- **Object type**: Agent collective with communication service
- **Characteristics**: Diverse perspectives, flexible interaction, chaotic with >3 agents
- **When to use**: Brainstorming, design debates, collaborative problem-solving
- **Example**: Design review with UX, engineering, product agents contributing
- **Platform**: Universal

**Explicit Handoff (O.WF + O.SVC)**
- **Structure**: Agents explicitly transfer control with state/context passing
- **Object type**: Workflow with typed handoff protocol
- **Characteristics**: Clear responsibility boundaries, audit trail, handoff overhead
- **When to use**: Different phases require different specialized expertise
- **Example**: Triage → technical → financial → resolution based on issue type
- **Platform**: Universal

**Magnetic (Adaptive) Routing (O.AGT + O.WF)**
- **Structure**: Manager agent builds dynamic task ledgers, routes to specialists
- **Object type**: Intelligent orchestration agent with workflow generation
- **Characteristics**: Adaptive, handles complexity, requires sophisticated manager
- **When to use**: Open-ended problems without predetermined solution paths
- **Example**: Incident response—dynamically routes to monitoring, diagnostic, repair specialists
- **Platform**: Desktop, Cloud (requires compute for adaptive planning)

### Topology Primitives

**Hub-and-Spoke Topology (O.AGT)**
- **Structure**: Central orchestrator coordinates all interactions
- **Characteristics**: Clear authority, easy oversight, single point of failure
- **When to use**: Mission-critical applications requiring centralized control
- **Object composition**: 1 orchestrator agent + N specialist agents
- **Communication**: All through central hub

**Mesh Topology (O.AGT + O.SVC)**
- **Structure**: Agents communicate directly peer-to-peer
- **Characteristics**: Distributed load, no bottleneck, complex coordination
- **When to use**: High-scale systems requiring fault tolerance
- **Object composition**: N agents + peer-to-peer communication service
- **Communication**: Direct agent-to-agent

**Hybrid Topology (O.AGT + O.SVC)**
- **Structure**: Hierarchical organization with peer collaboration within layers
- **Characteristics**: Centralized oversight + distributed execution, production-dominant pattern
- **When to use**: Most real-world scenarios (70%+ of production systems)
- **Object composition**: Orchestrator + Hub agents + Specialist agents + peer communication
- **Communication**: Hierarchical control, lateral collaboration

### Sub-Pattern Primitives

**Planner-Executor (O.AGT)**
- **Object composition**: Planner agent + Executor agent(s)
- **Function**: Separation of strategy (planning) vs. tactics (execution)
- **Reusability**: Common pattern across many workflows
- **Platform**: Universal

**Critic-Refiner / Actor-Critic (O.AGT)**
- **Object composition**: Actor agent + Critic agent
- **Function**: Iterative improvement through feedback loop
- **Quality impact**: 30-40% improvements on complex generation tasks
- **Platform**: Universal, especially valuable for quality-sensitive work

**Specialist Swarm (O.AGT + O.WF)**
- **Object composition**: Coordinator + Multiple specialist agents + Synthesis logic
- **Function**: Parallel specialized work with aggregation
- **Performance**: 45% faster resolution, 60% higher accuracy vs. single-agent
- **Platform**: Desktop, Cloud

**Supervisor-Worker Hierarchy (O.AGT)**
- **Object composition**: Supervisor agent + Worker agents
- **Function**: High-level orchestration + specialized execution
- **Characteristics**: Mirrors human team structures
- **Platform**: Universal

### Communication Protocol Primitives

**Model Context Protocol (MCP) (O.SVC)**
- **Function**: Universal agent-to-tool communication standard
- **Capabilities**: Tool discovery, capability description, invocation protocol
- **Adoption**: Universal across OpenAI, Anthropic, Google, Microsoft
- **Object type**: Service providing standardized interface
- **Use case**: Agent accessing external tools and APIs
- **Platform**: Universal

**Agent-to-Agent Protocol (A2A) (O.SVC)**
- **Function**: Peer agent communication standard
- **Components**:
  - Structured message envelopes (typed content)
  - Conversation protocols (multi-turn interactions)
  - AgentCards (self-description and capability advertisement)
  - Task lifecycle management (proposed, accepted, in-progress, completed, failed)
  - Modality negotiation (format adaptation)
- **Adoption**: Emerging standard, 150+ organizations backing
- **Object type**: Service providing peer communication infrastructure
- **Use case**: Multi-agent collaboration without central orchestrator
- **Platform**: Universal

### Orchestration Governance Primitives

**Circuit Breaker (O.GRD)**
- **Function**: Halt cascading failures, isolate problematic agents
- **Trigger**: Error rate threshold, timeout, resource exhaustion
- **Action**: Failover to backup, graceful degradation, alert
- **Platform**: Universal

**Rate Limiting (O.GRD)**
- **Function**: Protect resources from overload
- **Implementation**: Token bucket, sliding window, quota enforcement
- **Scope**: Per-agent, per-user, per-resource
- **Platform**: Universal

**Approval Gate (O.GRD)**
- **Function**: Human-in-loop verification at decision boundaries
- **When**: High-impact actions, irreversible operations, compliance requirements
- **Implementation**: Workflow pause + notification + explicit approval
- **Platform**: Universal

### Orchestration Platform Considerations

**Desktop**: Complex multi-agent orchestration, visualizations, debugging tools
**Mobile**: Simple sequential workflows, voice-coordinated agents
**XR**: Spatial agent representation, gesture-based coordination
**Ambient**: Background orchestration, proactive agent coordination
**CLI**: Scriptable orchestration, batch workflows, automated pipelines

---

## IV. Context Engineering Primitive Taxonomy

Context engineering primitives manage what information enters model context windows, when, and how.

### Retrieval Primitives

**Vector Similarity Search (O.FN + O.SVC)**
- **Function**: Semantic retrieval via embedding similarity
- **Implementation**: Vector database (Pinecone, Weaviate, pgvector)
- **Characteristics**: Fast (50-200ms), scalable, approximate nearest neighbor
- **Use case**: RAG systems, semantic search, knowledge retrieval
- **Platform**: Universal

**Keyword Search (O.FN)**
- **Function**: Exact or fuzzy text matching
- **Implementation**: Inverted indices, Elasticsearch, full-text search
- **Characteristics**: Fast (10-100ms), precise, limited to explicit terms
- **Use case**: Structured document retrieval, known-term search
- **Platform**: Universal

**Hybrid Retrieval (O.WF)**
- **Function**: Combine vector similarity + keyword + metadata filters
- **Impact**: 49% reduction in retrieval misses vs. vector-only
- **Implementation**: Parallel search → merge results → relevance ranking
- **Use case**: Production RAG systems requiring high accuracy
- **Platform**: Universal

**Graph Traversal (O.FN + O.DP)**
- **Function**: Navigate knowledge graph relationships
- **Implementation**: Graph databases (Neo4j), entity-relationship traversal
- **Characteristics**: Multi-hop reasoning, maintains entity connections
- **Use case**: Complex question answering, connected knowledge retrieval
- **Platform**: Desktop, Cloud

### Context Assembly Primitives

**Hierarchical Summarization (O.FN + O.WF)**
- **Function**: Multi-level abstraction of content
- **Pattern**: Map-reduce—section summaries → summary of summaries → gist
- **Trade-off**: Speed vs. information loss
- **Use case**: Processing documents exceeding context window
- **Platform**: Universal

**Sliding Window (O.FN)**
- **Function**: Process long content in overlapping segments
- **Parameters**: Window size, overlap size
- **Characteristics**: Maintains continuity, handles arbitrary length
- **Use case**: Long document processing, continuous streams
- **Platform**: Universal

**Query Transformation (O.FN + O.AGT)**
- **Function**: Optimize search queries based on initial results
- **Techniques**: Query expansion, reformulation, clarification
- **Implementation**: Agent analyzes results → generates better query → re-search
- **Use case**: Agentic RAG, iterative refinement
- **Platform**: Universal

**Context Compression (O.FN)**
- **Function**: Condense information to fit context window
- **Techniques**: Abstractive summarization, key phrase extraction, entity focus
- **Trade-off**: Detail loss vs. window efficiency
- **Use case**: Maximizing relevant information in limited context
- **Platform**: Universal

### Caching Primitives

**Prompt Caching (O.SVC)**
- **Function**: Reuse static context portions across requests
- **Economics** (Production validated):
  - Cache write: 1.25x-2x base price (TTL dependent)
  - Cache read: 0.1x base price (90% discount)
  - Cache miss: Full base price
- **Break-even**: Static content caches profitably after 2 uses
- **Impact**: 40-90% cost reduction, 10-85% latency reduction in production
- **Platform**: Universal (Anthropic, OpenAI, Google support)

**Result Caching (O.SVC + O.DP)**
- **Function**: Cache entire API responses for repeated queries
- **Invalidation**: Time-based (TTL) or event-based (content update)
- **Use case**: Frequently-asked questions, common workflows
- **Platform**: Universal

**Embedding Caching (O.MOD + O.DP)**
- **Function**: Store pre-computed embeddings for documents
- **Update strategy**: Recompute on content change
- **Use case**: Large document collections with infrequent updates
- **Platform**: Universal

### Window Management Primitives

**Context Pruning (O.FN + O.EVL)**
- **Function**: Remove outdated or contradictory information
- **Impact**: 54% improvement in specialized agent benchmarks
- **Techniques**: Temporal decay, relevance scoring, contradiction detection
- **Use case**: Long conversations, maintaining coherence
- **Platform**: Universal

**Context Offloading (O.WF)**
- **Function**: Separate workspace for heavy processing
- **Pattern**: Heavy computation off-thread → return summaries only
- **Impact**: 8x cleaner signal (76% vs. 9% when in main thread)
- **Use case**: Large data analysis, diagnostic operations
- **Platform**: Desktop, Cloud

**Working Memory Management (O.STM)**
- **Function**: Allocate finite context budget across competing needs
- **Strategy**: Prioritize critical info, compress non-essential, prune stale
- **Use case**: Context-constrained operations
- **Platform**: Universal

### RAG Strategy Primitives

**Basic RAG (O.WF)**
- **Pattern**: Query → vector search → retrieve passages → inject in prompt
- **Characteristics**: Simple, fast, limited to single-step retrieval
- **Use case**: Simple Q&A, straightforward fact lookup
- **Platform**: Universal

**Hybrid RAG (O.WF)**
- **Pattern**: Query → vector + keyword + metadata search → merge → rank → inject
- **Performance**: 49% fewer retrieval misses vs. vector-only
- **Use case**: Production systems requiring accuracy
- **Platform**: Universal

**GraphRAG (O.WF + O.DP)**
- **Pattern**: Query → graph traversal → entity relationships → retrieve connected knowledge
- **Characteristics**: Multi-hop reasoning, maintains connections
- **Use case**: Complex questions requiring reasoning across entities
- **Platform**: Desktop, Cloud

**Agentic RAG (O.AGT + O.WF)**
- **Pattern**: Agent-driven iterative retrieval with feedback loops
- **Flow**: Initial query → evaluate results → refine query → re-search → synthesize
- **Characteristics**: Self-improving, adaptive, higher quality
- **Use case**: Research tasks, complex information synthesis
- **Platform**: Desktop, Cloud

### Context Platform Considerations

**Desktop**: Extended context windows, complex RAG, large knowledge bases
**Mobile**: Compressed context, quick retrieval, cached summaries
**XR**: Spatial context visualization, immersive knowledge navigation
**Ambient**: Minimal context, highly compressed, proactive assembly
**CLI**: Scriptable context assembly, batch processing, automated pipelines

---

## V. Object Ontology

The fundamental classification system for computational entities in the Personal Ontology.

### Function Objects (Computational Operations)

**O.FN: Function**
- Stateless computational transformations
- Pure functions: Input → Processing → Output
- Examples: Text transformation, calculation, classification
- Characteristics: Deterministic, composable, testable

**O.SVC: Service**
- Stateful, always-available capabilities
- Persistent operations across requests
- Examples: Databases, APIs, authentication services, caching layers
- Characteristics: Shared state, concurrent access, lifecycle management

**O.WF: Workflow**
- Orchestrated sequences of operations
- Coordination logic for multi-step processes
- Examples: Data pipelines, approval chains, multi-agent orchestration
- Characteristics: State machines, error handling, branching logic

**O.AGT: Agent**
- Autonomous entities with goals and memory
- Decision-making and proactive behavior
- Examples: Research agents, coding assistants, orchestrator agents
- Characteristics: Persistent memory, tool use, goal-directed, learning

### Data Objects (Information Storage and Access)

**O.DP: Data Persistence**
- Long-term storage systems
- Structured and unstructured data at rest
- Examples: Databases, file systems, vector stores, knowledge graphs
- Characteristics: Durability, queryability, scalability

**O.MOD: Model**
- Learned representations and inference engines
- Statistical patterns or neural networks
- Examples: LLMs, embedding models, classifiers, specialized AI models
- Characteristics: Training data dependent, inference capability, version management

**O.STM: Short-term Memory**
- Volatile, session-scoped state
- Immediate context and working memory
- Examples: Conversation history, active task state, temporary buffers
- Characteristics: Fast access, limited capacity, ephemeral

**O.ARC: Archive**
- Cold storage for infrequently accessed data
- Long-term preservation with reduced availability
- Examples: Backups, audit logs, historical records
- Characteristics: High capacity, low cost, higher latency

### Interface Objects (Human-Technology Boundaries)

**O.SRF: Surface**
- Visual or spatial presentation layers
- User interface elements and layouts
- Examples: Windows, canvases, spatial environments, dashboards
- Characteristics: Human perception-oriented, context-specific rendering

**O.SNS: Sensor**
- Input capture and signal acquisition
- Transduction from physical to digital
- Examples: Cameras, microphones, touch sensors, GPS, biometric readers
- Characteristics: Real-time capture, signal processing, calibration needs

**O.ACT: Actuator**
- Output execution and physical manifestation
- Transduction from digital to physical
- Examples: Displays, speakers, haptics, robotic controls, 3D printers
- Characteristics: Real-time rendering, fidelity constraints, feedback loops

**O.INS: Instrument**
- Specialized input devices and control mechanisms
- Precision tools for specific interactions
- Examples: Stylus, MIDI controller, game controller, specialized keyboards
- Characteristics: Domain-specific, tactile feedback, learned skill requirements

### Governance Objects (Policy Enforcement and Quality)

**O.GRD: Guard**
- Security and safety enforcement mechanisms
- Preventive controls and access management
- Examples: Authentication, authorization, circuit breakers, rate limiters, content filters
- Characteristics: Real-time enforcement, audit logging, fail-safe defaults

**O.EVL: Evaluator**
- Quality assessment and measurement systems
- Judgment and scoring mechanisms
- Examples: Test suites, validators, critics, quality scorers, benchmark runners
- Characteristics: Criteria-based, measurable, feedback-providing

**O.CPL: Compliance**
- Regulatory and policy adherence systems
- Audit trails and reporting mechanisms
- Examples: GDPR compliance, audit logging, retention policies, access logs
- Characteristics: Regulatory-driven, immutable records, reporting capability

**O.POL: Policy**
- Rules and constraints governing behavior
- Declarative specifications of acceptable actions
- Examples: Data handling policies, approval workflows, operational constraints
- Characteristics: Human-readable, version-controlled, enforcement-independent

### Object Composition Patterns

Objects combine to create higher-level capabilities:

**Pattern: Intelligent Agent System**
- O.AGT (agent) + O.MOD (LLM) + O.STM (conversation memory) + O.DP (long-term memory) + O.SVC (tool access) + O.GRD (safety controls)

**Pattern: RAG System**
- O.FN (retrieval logic) + O.SVC (vector database) + O.MOD (embeddings) + O.WF (query → retrieve → inject workflow)

**Pattern: Orchestrated Workflow**
- O.WF (coordination logic) + O.AGT (multiple agents) + O.SVC (communication protocol) + O.GRD (approval gates) + O.EVL (quality checks)

**Pattern: Context Assembly**
- O.FN (relevance scoring) + O.DP (memory stores) + O.STM (working memory) + O.WF (retrieval workflow)

---

## VI. Entity State Taxonomy

Tools, primitives, and workflows transition through defined lifecycle states. State tracking enables intelligent management.

### Tool Lifecycle States

**Active Use**
- Regular engagement, current version, core workflows
- Action: Monitor usage, extract patterns, identify primitives
- Transition triggers: Superseded by better tool, workflow changes, feature gaps

**Trial**
- Evaluating for adoption or feature mining, time-bounded
- Action: Systematic assessment, primitive identification, reuse validation
- Transition triggers: Decision to adopt, extract primitives, or reject

**Primitive Repository**
- Valuable features identified, not for direct use, extraction pending
- Action: Document extractable primitives, assess consolidation opportunities
- Transition triggers: Primitives extracted and cataloged → Extraction Complete

**Consolidation Target**
- Will merge with others into bespoke composition
- Action: Map overlapping capabilities, design unified composition
- Transition triggers: Bespoke tool created → Deprecated or Extraction Complete

**Extraction Complete**
- Primitives cataloged and validated through reuse, safe to archive
- Action: Archive tool, maintain primitive catalog entries
- Transition triggers: Source tool discontinued, primitives superseded

**Deprecated**
- No longer relevant, no primitives worth preserving
- Action: Remove from active consideration, document replacement path
- Transition triggers: Time-based archive, complete removal

### Primitive Lifecycle States

**Experimental**
- Newly identified, not yet validated through composition
- Action: Document minimally, await reuse validation
- Transition triggers: Successful reuse → Validated

**Validated**
- Used successfully in at least one composition
- Action: Complete documentation, note composition patterns
- Transition triggers: Repeated reuse → Production

**Production**
- High reuse rate (10+ compositions), well-documented, reliable
- Action: Maintain actively, monitor performance, update as needed
- Transition triggers: Superseded by better primitive → Deprecated

**Deprecated**
- Better alternative identified or no longer compatible
- Action: Mark deprecated, document migration path, eventual removal
- Transition triggers: Complete migration → Removed

### Apparatus Lifecycle States

**Candidate**
- Pattern detected but not yet formalized
- Action: Monitor stability, validate frequency, assess value
- Transition triggers: Pattern stable + valuable → Named Apparatus

**Named Apparatus**
- Formalized workflow with documented structure
- Action: Optimize execution, track effectiveness, enable shortcuts
- Transition triggers: Automation opportunities → Automated Apparatus

**Automated Apparatus**
- Execution automated, minimal manual intervention
- Action: Monitor reliability, collect feedback, refine automation
- Transition triggers: Workflow changes, becomes obsolete → Deprecated

**Deprecated Apparatus**
- No longer used, superseded by different pattern
- Action: Document replacement, remove automation, archive
- Transition triggers: Complete disuse → Removed

---

## VII. Work Mode Taxonomy

### Mode 1: Creation (Void → Existence)

**Essence**: Bringing ideas into reality, manifesting new artifacts

**Human role**: Vision, taste, judgment, direction, quality evaluation

**AI role**: Generation, variation, implementation, refinement, primitive composition

**Interface paradigm**: Specification → generation → evaluation → refinement loop

**Platform optimization**:
- Desktop: Extended creation sessions, complex compositions, detailed control
- Mobile: Quick capture, voice-driven ideation, opportunistic creation
- XR: Spatial creation, gesture-based manipulation, immersive design
- Ambient: Background synthesis, opportunistic capture, automated generation
- CLI: Templated generation, batch creation, scripted workflows

**Object types**: O.FN (creation functions), O.WF (generation workflows), O.AGT (generative agents)

**Success metric**: Quality of output relative to intent, iteration efficiency

### Mode 2: Transformation (State A → State B)

**Essence**: Modifying, improving, or converting existing artifacts

**Human role**: Intent specification, quality evaluation, trade-off judgment

**AI role**: Analysis, proposal generation, transformation execution, optimization

**Interface paradigm**: Current state + intent → analysis → proposed changes → refinement → execution

**Platform optimization**:
- Desktop: Complex multi-dimensional optimization, detailed comparison, batch operations
- Mobile: Quick edits, voice-directed refinement, gesture-based adjustments
- XR: Spatial manipulation, gesture-based transformation, immersive editing
- Ambient: Automated optimization, background processing, scheduled transformations
- CLI: Batch transformations, automated pipelines, scripted operations

**Object types**: O.FN (transformation functions), O.WF (editing workflows), O.EVL (quality evaluation)

**Success metric**: Degree of improvement, efficiency of transformation process

### Mode 3: Comprehension (Unknown → Known)

**Essence**: Understanding existing information, extracting insights, making sense

**Human role**: Question framing, relevance judgment, synthesis direction

**AI role**: Information gathering, pattern recognition, synthesis, explanation

**Interface paradigm**: Question → research → pattern identification → explanation → deeper exploration

**Platform optimization**:
- Desktop: Deep research, extensive synthesis, comprehensive analysis
- Mobile: Quick lookups, voice queries, summary digests
- XR: Spatial knowledge mapping, immersive learning, 3D data visualization
- Ambient: Continuous monitoring, proactive insights, background analysis
- CLI: Automated research pipelines, batch analysis, scripted investigations

**Object types**: O.FN (analysis functions), O.SVC (search services), O.AGT (research agents)

**Success metric**: Depth and accuracy of understanding, insight quality

### Mode 4: Extraction (Composition → Primitives)

**Essence**: Decomposing tools into reusable components, cataloging valuable features

**Human role**: Identifying valuable features, assessing reuse potential, directing consolidation

**AI role**: Systematic analysis, primitive documentation, combination suggestions, composition execution

**Interface paradigm**: Analysis → curation → composition loop

**Platform optimization**:
- Desktop: Deep analysis, comprehensive cataloging, complex compositions, precision control
- Mobile: Quick feature notes, opportunistic identification, lightweight compositions
- XR: Spatial feature mapping, gesture-based categorization, immersive comparison
- Ambient: Usage pattern observation, automated primitive discovery, background cataloging
- CLI: Automated extraction, programmatic composition, batch operations

**Object types**: All types as primitive sources—functions, data, interface, governance objects

**Success metric**: Quality of primitive catalog, effectiveness of composed tools, reduction in tool redundancy without feature loss

---

## VIII. Platform Overlays

Each platform imposes distinct constraints and affordances, requiring adapted implementations of universal primitives.

### Desktop Platform Overlay

**Constitutional Emphasis**: L3-L6 (Interaction, Choreographic, Cognitive, Composition), with L7 (Meta-Orchestration)

**Frequency Adaptation**:
- F1-F3: Primary domain (Interface actions through Workflow orchestration)
- F4-F6: Secondary domain (Context switching through Configuration)
- Keyboard-centric, mouse-precise, extended-focus

**Dimensional Configuration**:
- Agency: High control, precision-optimized
- Intimacy: Distant (desk-bound, stationary)
- Cognitive: Deep focus, extended attention, complex thought
- Temporal: Long sessions (hours)
- Embodiment: Seated, stationary, two-handed precision
- Information: High density, multiple windows, rich visualization

**Platform Constraints**:
- Stationary—limited mobility, requires dedicated workspace
- High bandwidth—wired/stable connections, rich media
- Large screen—multiple windows, high information density possible
- Precision input—keyboard shortcuts, mouse accuracy
- Extended sessions—designed for hours-long work
- Powerful compute—can handle complex operations locally

**Primitive Specialization**:
- Complex multi-agent orchestration
- Deep analysis and synthesis
- Precision editing and creation
- Visual programming and composition
- Comprehensive memory operations
- Sophisticated context engineering

**Synapticality Optimization**:
- Keyboard shortcuts (bypassing mouse navigation)
- Command palettes (text-driven navigation)
- Split-pane layouts (parallel workflows)
- Tab management (context preservation)
- Vim motions (thought-speed text navigation)
- Scriptability (automation of repetitive tasks)

**Object Distribution**:
- O.FN: Complex transformations, computational workflows
- O.AGT: Sophisticated agents with rich interfaces
- O.WF: Multi-step workflows with visualization
- O.DP: Local databases, file systems, large-scale storage
- O.SRF: Multi-window layouts, rich visualizations
- O.INS: Keyboard, mouse, specialized input devices

### Mobile Platform Overlay

**Constitutional Emphasis**: L1-L3 (Transduction, Perceptual, Interaction), L0 (Ambient Intelligence potential)

**Frequency Adaptation**:
- F1-F2: Primary domain (Interface actions, Task execution)
- F4: Daily routines (habitual patterns)
- Touch-centric, voice-enabled, glanceable

**Dimensional Configuration**:
- Agency: Moderate control, convenience-optimized
- Intimacy: Proximal (in pocket, in hand, always present)
- Cognitive: Interruptible, opportunistic, quick-reference
- Temporal: Short sessions (seconds to minutes)
- Embodiment: Mobile, standing/walking, one-handed
- Information: Limited display, voice alternative

**Platform Constraints**:
- Small screen—limited information simultaneously visible
- Touch input—less precise than mouse/keyboard
- Mobile connectivity—variable bandwidth, potential offline
- Battery constraints—power efficiency critical
- Interruption-prone—designed for short bursts
- Context-rich—GPS, motion, biometric sensors

**Primitive Specialization**:
- Quick capture (voice notes, photos, location)
- Opportunistic creation (ideas on-the-go)
- Communication (messages, calls, notifications)
- Context-aware actions (location-based, time-based)
- Glanceable information (dashboards, summaries)

**Synapticality Optimization**:
- Voice interface (hands-free, eyes-free)
- Predictive loading (anticipate likely actions)
- Offline capability (core functions work disconnected)
- Gesture shortcuts (swipe patterns, long-press)
- Notification intelligence (right time, right info)

**Object Distribution**:
- O.FN: Quick transformations, communication functions
- O.WF: Simple workflows, notification-driven
- O.DP: Synchronized subsets of full data
- O.SRF: Touch-optimized, glanceable interfaces
- O.SNS: Rich sensor array (GPS, motion, biometric)

### XR Platform Overlay

**Constitutional Emphasis**: L0-L2 (Physical, Transduction, Perceptual), L3 (Interaction Grammar—spatial)

**Frequency Adaptation**:
- F1-F2: Immersive domain (Spatial actions, embodied tasks)
- F3: Specialized workflows (3D creation, spatial analysis)

**Dimensional Configuration**:
- Agency: Embodied control, gesture-driven
- Intimacy: Enveloping (immersed in digital space)
- Cognitive: Flow state, spatial reasoning, embodied cognition
- Temporal: Medium sessions (30 min - 2 hours)
- Embodiment: Standing/moving, full-body, gesture-rich
- Information: Spatial 3D, infinite canvas, embodied data

**Platform Constraints**:
- Immersive display—360° vision, depth perception
- Gesture input—hand tracking, gaze, voice
- Compute limitations—mobile processors, thermal constraints
- Social isolation—removes user from physical environment
- Fatigue—physical and cognitive load from immersion
- Spatial computing—new interaction paradigms

**Primitive Specialization**:
- Spatial creation and manipulation
- Immersive data visualization
- Embodied learning experiences
- Gesture-based workflows
- 3D knowledge mapping
- Collaborative spatial work

**Synapticality Optimization**:
- Spatial memory (persistent object placement)
- Gesture vocabulary (natural hand movements)
- Gaze-driven navigation (where you look = interaction target)
- Voice augmentation (complement gestures with speech)
- Haptic feedback (tactile confirmation)

**Object Distribution**:
- O.SRF: Spatial surfaces, 3D environments
- O.SNS: Hand tracking, gaze tracking, spatial audio
- O.ACT: Spatial audio, haptics, visual rendering
- O.FN: Spatial transformations, 3D operations
- O.WF: Embodied workflows, spatial sequences

### Ambient Platform Overlay

**Constitutional Emphasis**: L0 (Physical substrate—always sensing), L7 (Meta-orchestration—continuous learning)

**Frequency Adaptation**:
- F0: Continuous (subconscious, always-on)
- F2-F4: Proactive (anticipatory actions, background optimization)

**Dimensional Configuration**:
- Agency: Low explicit control, high automation
- Intimacy: Pervasive (environmental, everywhere)
- Cognitive: Subconscious, effortless, anticipatory
- Temporal: Continuous (always-on background)
- Embodiment: Distributed, environmental, non-explicit
- Information: Minimal explicit display, proactive alerts

**Platform Constraints**:
- No primary interface—operates in background
- Sensor-rich—environmental monitoring, context detection
- Low-power—must operate continuously on limited energy
- Privacy-sensitive—always observing raises concerns
- Latency-tolerant—non-interactive, can process async
- Pattern-dependent—effectiveness grows with observation data

**Primitive Specialization**:
- Continuous monitoring and pattern detection
- Proactive suggestions and automations
- Background processing and optimization
- Context-aware triggering
- Predictive preparation
- Usage learning

**Synapticality Optimization**:
- Zero-UI (no conscious interaction required)
- Anticipatory loading (prepare before needed)
- Background processing (work done invisibly)
- Smart defaults (learn preferences)
- Proactive alerts (right time, right place)

**Object Distribution**:
- O.SNS: Environmental sensors, context detection
- O.AGT: Background agents, pattern recognition
- O.WF: Automated workflows, scheduled tasks
- O.EVL: Pattern scoring, anomaly detection
- O.GRD: Privacy controls, usage boundaries

### CLI Platform Overlay

**Constitutional Emphasis**: L3-L5 (Interaction Grammar—textual, Choreographic, Cognitive)

**Frequency Adaptation**:
- F2-F3: Primary domain (Task execution, Workflow orchestration)
- F5-F6: Power user domain (Configuration, Strategic review)

**Dimensional Configuration**:
- Agency: Maximum control, expert-optimized
- Intimacy: Terminal-bound (text-centric)
- Cognitive: Precise, intentional, composable
- Temporal: Variable (quick commands to long scripts)
- Embodiment: Keyboard-only, text-driven
- Information: Text-based, scriptable, pipeable

**Platform Constraints**:
- Text-only—no graphical interface by default
- Keyboard-driven—mouse rare or absent
- Expert-oriented—assumes technical knowledge
- Scriptable—everything programmable and automatable
- Composable—pipe output of one tool to another
- System-level—access to low-level operations

**Primitive Specialization**:
- Automation and scripting
- Batch operations
- Pipeline composition
- System-level access
- Reproducible workflows
- Version-controlled operations

**Synapticality Optimization**:
- Command abbreviation (aliases, shortcuts)
- Tab completion (fast navigation)
- History search (recall past commands)
- Pipes and composition (combine primitives)
- Scripts and automation (codify workflows)
- Dotfiles (portable configuration)

**Object Distribution**:
- O.FN: Pure functions, composable operations
- O.WF: Scripts, pipelines, automated sequences
- O.SVC: Daemons, background services
- O.DP: File systems, databases, logs
- O.GRD: Access controls, audit logs

---

## IX. Conclusion

Taxonomies are not decorative—they are **operational typologies** enabling decisions. Every classification exists to answer a question:

**Object Ontology**: "What type of computational entity is this?"
**Memory Taxonomy**: "What tier of memory should this use?"
**Orchestration Taxonomy**: "Which coordination pattern fits this workflow?"
**Context Taxonomy**: "How should information be assembled?"
**Entity States**: "What lifecycle stage, and what action?"
**Work Modes**: "What type of cognitive work am I doing?"
**Platform Overlays**: "How does this platform change the implementation?"

Taxonomies must be:
- **Mutually exclusive**: Clear boundaries between categories
- **Collectively exhaustive**: Cover all relevant cases
- **Operationally useful**: Guide real decisions
- **Future-accommodating**: Extensible as technology evolves

**The taxonomic imperative**: Build categorization systems that serve practitioners making decisions, not just theorists describing reality. Classification is valuable only when it changes action.