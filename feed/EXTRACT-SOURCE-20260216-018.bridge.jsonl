{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "64c65f75-4703-5304-a51f-621189608d6d", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0001", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "To set up a repository for automated code writing and review, establish a loop where a coding agent writes code, the repository enforces risk-aware checks before merging, a code review agent validates the PR, evidence (tests, browser, review) is machine-verifiable, and findings are converted into repeatable harness cases.", "line_start": 18, "line_end": 25, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.4, 0.1, 0.3, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "PraxisHook", "name": "To set up a repository for automated code writing and review, establish a loop w", "content": "To set up a repository for automated code writing and review, establish a loop where a coding agent writes code, the repository enforces risk-aware checks before merging, a code review agent validates the PR, evidence (tests, browser, review) is machine-verifiable, and findings are converted into repeatable harness cases.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 18, "line_end": 25, "atom_id": "ATOM-SOURCE-20260216-018-0001"}, "metadata": {"category": "praxis_hook", "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.4, 0.1, 0.3, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "379f1c99-8506-50fa-98a0-6b28f208f7c8", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0002", "source_id": "SOURCE-20260216-018", "category": "framework", "content": "A machine-readable contract for code repositories should define risk tiers by path, required checks by tier, documentation drift rules for control-plane changes, and evidence requirements for UI/critical flows.", "line_start": 47, "line_end": 51, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "Framework", "name": "A machine-readable contract for code repositories should define risk tiers by pa", "content": "A machine-readable contract for code repositories should define risk tiers by path, required checks by tier, documentation drift rules for control-plane changes, and evidence requirements for UI/critical flows.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 47, "line_end": 51, "atom_id": "ATOM-SOURCE-20260216-018-0002"}, "metadata": {"category": "framework", "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "68b39162-a815-5915-b22b-fd9af0a3cdff", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0003", "source_id": "SOURCE-20260216-018", "category": "claim", "content": "Using a single machine-readable contract removes ambiguity and prevents silent drift between scripts, workflow files, and policy documents in a code repository.", "line_start": 79, "line_end": 80, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.2, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "Claim", "name": "Using a single machine-readable contract removes ambiguity and prevents silent d", "content": "Using a single machine-readable contract removes ambiguity and prevents silent drift between scripts, workflow files, and policy documents in a code repository.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 79, "line_end": 80, "atom_id": "ATOM-SOURCE-20260216-018-0003"}, "metadata": {"category": "claim", "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.2, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "5079ecf5-2a84-5356-850c-55b0781aa1eb", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0004", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "To optimize CI, run a `risk-policy-gate` first to verify deterministic policy and review-agent state, and only then initiate `test/build/security` fanout jobs, avoiding wasted CI minutes on PRs blocked by policy or unresolved review findings.", "line_start": 83, "line_end": 88, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "PraxisHook", "name": "To optimize CI, run a `risk-policy-gate` first to verify deterministic policy an", "content": "To optimize CI, run a `risk-policy-gate` first to verify deterministic policy and review-agent state, and only then initiate `test/build/security` fanout jobs, avoiding wasted CI minutes on PRs blocked by policy or unresolved review findings.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 83, "line_end": 88, "atom_id": "ATOM-SOURCE-20260216-018-0004"}, "metadata": {"category": "praxis_hook", "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "1ad7eb8d-c3e4-5436-8c85-bdd41da7bff3", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0005", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "Enforce current-head SHA discipline by treating review state as valid only when it matches the current PR head commit, waiting for the review check run on `headSha`, ignoring stale summary comments, failing if the latest review run is non-success or times out, and requiring reruns after each synchronize/push.", "line_start": 103, "line_end": 110, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.5, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "PraxisHook", "name": "Enforce current-head SHA discipline by treating review state as valid only when", "content": "Enforce current-head SHA discipline by treating review state as valid only when it matches the current PR head commit, waiting for the review check run on `headSha`, ignoring stale summary comments, failing if the latest review run is non-success or times out, and requiring reruns after each synchronize/push.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 103, "line_end": 110, "atom_id": "ATOM-SOURCE-20260216-018-0005"}, "metadata": {"category": "praxis_hook", "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.5, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "be3b021b-f33a-5fb9-b30c-87f4759f31b1", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0006", "source_id": "SOURCE-20260216-018", "category": "claim", "content": "Skipping current-head SHA discipline can lead to merging a PR using stale 'clean' evidence.", "line_start": 111, "line_end": 112, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.5, 0.6, 0.1, 0.2, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "Claim", "name": "Skipping current-head SHA discipline can lead to merging a PR using stale 'clean", "content": "Skipping current-head SHA discipline can lead to merging a PR using stale 'clean' evidence.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 111, "line_end": 112, "atom_id": "ATOM-SOURCE-20260216-018-0006"}, "metadata": {"category": "claim", "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.5, 0.6, 0.1, 0.2, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "0ef729b6-40e4-59e2-b888-b40902b984c3", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0007", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "To prevent duplicate bot comments and race conditions when multiple workflows request reruns, use exactly one workflow as the canonical rerun requester and deduplicate by a marker plus `sha:<head>`.", "line_start": 115, "line_end": 117, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "PraxisHook", "name": "To prevent duplicate bot comments and race conditions when multiple workflows re", "content": "To prevent duplicate bot comments and race conditions when multiple workflows request reruns, use exactly one workflow as the canonical rerun requester and deduplicate by a marker plus `sha:<head>`.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 115, "line_end": 117, "atom_id": "ATOM-SOURCE-20260216-018-0007"}, "metadata": {"category": "praxis_hook", "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "1ae61ee6-e0ba-58b8-9292-bf2c617c5793", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0008", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "Implement an automated remediation loop where, if review findings are actionable, a coding agent reads review context, patches code, runs focused local validation, and pushes a fix commit to the same PR branch, ensuring determinism by pinning the model and effort for reproducibility, skipping stale comments, and never bypassing policy gates.", "line_start": 130, "line_end": 139, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.8, 0.3, 0.1, 0.4, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "PraxisHook", "name": "Implement an automated remediation loop where, if review findings are actionable", "content": "Implement an automated remediation loop where, if review findings are actionable, a coding agent reads review context, patches code, runs focused local validation, and pushes a fix commit to the same PR branch, ensuring determinism by pinning the model and effort for reproducibility, skipping stale comments, and never bypassing policy gates.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 130, "line_end": 139, "atom_id": "ATOM-SOURCE-20260216-018-0008"}, "metadata": {"category": "praxis_hook", "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.8, 0.3, 0.1, 0.4, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "1be7ff18-29b2-501c-9676-f871649bd479", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0009", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "After a clean current-head rerun, auto-resolve unresolved threads where all comments are from the review bot, but never auto-resolve human-participated threads, then rerun the policy gate to reflect the new state of required-conversation-resolution.", "line_start": 142, "line_end": 147, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "PraxisHook", "name": "After a clean current-head rerun, auto-resolve unresolved threads where all comm", "content": "After a clean current-head rerun, auto-resolve unresolved threads where all comments are from the review bot, but never auto-resolve human-participated threads, then rerun the policy gate to reflect the new state of required-conversation-resolution.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 142, "line_end": 147, "atom_id": "ATOM-SOURCE-20260216-018-0009"}, "metadata": {"category": "praxis_hook", "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "8b0f6ce4-a5f6-5a6f-89b8-4e269058176f", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0010", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "For UI or user-flow changes, require evidence manifests and assertions in CI as first-class proof, ensuring that required flows exist, expected entrypoints and account identities are used, and artifacts are fresh and valid.", "line_start": 150, "line_end": 156, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "PraxisHook", "name": "For UI or user-flow changes, require evidence manifests and assertions in CI as", "content": "For UI or user-flow changes, require evidence manifests and assertions in CI as first-class proof, ensuring that required flows exist, expected entrypoints and account identities are used, and artifacts are fresh and valid.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 150, "line_end": 156, "atom_id": "ATOM-SOURCE-20260216-018-0010"}, "metadata": {"category": "praxis_hook", "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "7e6e1e2b-77fd-573a-9748-5ba5131d312f", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0011", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "To manage code review agents, use a remediation agent (e.g., Codex Action), a canonical rerun workflow (`greptile-rerun.yml`), a stale-thread cleanup workflow (`greptile-auto-resolve-threads.yml`), and a preflight policy workflow (`risk-policy-gate.yml`).", "line_start": 161, "line_end": 166, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "PraxisHook", "name": "To manage code review agents, use a remediation agent (e.g., Codex Action), a ca", "content": "To manage code review agents, use a remediation agent (e.g., Codex Action), a canonical rerun workflow (`greptile-rerun.yml`), a stale-thread cleanup workflow (`greptile-auto-resolve-threads.yml`), and a preflight policy workflow (`risk-policy-gate.yml`).", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 161, "line_end": 166, "atom_id": "ATOM-SOURCE-20260216-018-0011"}, "metadata": {"category": "praxis_hook", "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "a34d5f93-a000-5f38-bdd9-2a26c6ae1f36", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0012", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "Preserve incident memory and grow long-term coverage by establishing a harness-gap loop where production regressions lead to a harness gap issue, a case is added, and its SLA is tracked.", "line_start": 162, "line_end": 164, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "PraxisHook", "name": "Preserve incident memory and grow long-term coverage by establishing a harness-g", "content": "Preserve incident memory and grow long-term coverage by establishing a harness-gap loop where production regressions lead to a harness gap issue, a case is added, and its SLA is tracked.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 162, "line_end": 164, "atom_id": "ATOM-SOURCE-20260216-018-0012"}, "metadata": {"category": "praxis_hook", "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "11faadda-eeb4-540c-be1b-cc7c201849aa", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0013", "source_id": "SOURCE-20260216-018", "category": "framework", "content": "Key lessons for running automated code review in PRs include: deterministic ordering (preflight gate before CI fanout), non-negotiable current-head SHA matching, a single canonical writer for review rerun requests, treating vulnerability language and weak-confidence summaries as actionable, auto-resolving bot-only threads only after clean current-head evidence, and using a remediation agent to shorten loop time with strict guardrails.", "line_start": 167, "line_end": 175, "chaperone": {"context_type": "anecdote", "argument_role": "claim", "tension_vector": [0.5, 0.5, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "Framework", "name": "Key lessons for running automated code review in PRs include: deterministic orde", "content": "Key lessons for running automated code review in PRs include: deterministic ordering (preflight gate before CI fanout), non-negotiable current-head SHA matching, a single canonical writer for review rerun requests, treating vulnerability language and weak-confidence summaries as actionable, auto-resolving bot-only threads only after clean current-head evidence, and using a remediation agent to shorten loop time with strict guardrails.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 167, "line_end": 175, "atom_id": "ATOM-SOURCE-20260216-018-0013"}, "metadata": {"category": "framework", "chaperone": {"context_type": "anecdote", "argument_role": "claim", "tension_vector": [0.5, 0.5, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "6802a53e-ea63-50d3-b755-d5386438d605", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0014", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "When using a different reviewer for code, maintain the same control-plane semantics and only swap integration points.", "line_start": 167, "line_end": 168, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.4, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "PraxisHook", "name": "When using a different reviewer for code, maintain the same control-plane semant", "content": "When using a different reviewer for code, maintain the same control-plane semantics and only swap integration points.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 167, "line_end": 168, "atom_id": "ATOM-SOURCE-20260216-018-0014"}, "metadata": {"category": "praxis_hook", "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.4, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "ca1b9c13-0579-570b-9f9e-2c17d091c0c7", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0015", "source_id": "SOURCE-20260216-018", "category": "framework", "content": "A general pattern for automated code review involves a `code review agent`, a `remediation agent`, and a `risk policy gate`, which can be implemented with specific tools like Greptile for code review, Codex Action for remediation, and dedicated workflows for reruns, cleanup, and preflight policies.", "line_start": 178, "line_end": 185, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.4, 0.1, 0.3, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "Framework", "name": "A general pattern for automated code review involves a `code review agent`, a `r", "content": "A general pattern for automated code review involves a `code review agent`, a `remediation agent`, and a `risk policy gate`, which can be implemented with specific tools like Greptile for code review, Codex Action for remediation, and dedicated workflows for reruns, cleanup, and preflight policies.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 178, "line_end": 185, "atom_id": "ATOM-SOURCE-20260216-018-0015"}, "metadata": {"category": "framework", "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.4, 0.1, 0.3, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "d4903dda-c09d-5c42-ac54-6bacafc81a71", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0016", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "A recommended pattern for managing a repository with agents involves: 1. Combining risk and merge policies into a single contract. 2. Enforcing a preflight gate before expensive CI runs. 3. Requiring a clean code-review-agent state for the current head SHA. 4. Remediating findings in-branch and rerunning deterministically if they exist. 5. Auto-resolving only bot-only stale threads after a clean rerun. 6. Requiring browser evidence for UI/flow changes. 7. Converting incidents into harness cases and tracking loop SLOs.", "line_start": 179, "line_end": 187, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.3, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "PraxisHook", "name": "A recommended pattern for managing a repository with agents involves: 1. Combini", "content": "A recommended pattern for managing a repository with agents involves: 1. Combining risk and merge policies into a single contract. 2. Enforcing a preflight gate before expensive CI runs. 3. Requiring a clean code-review-agent state for the current head SHA. 4. Remediating findings in-branch and rerunning deterministically if they exist. 5. Auto-resolving only bot-only stale threads after a clean rerun. 6. Requiring browser evidence for UI/flow changes. 7. Converting incidents into harness cases and tracking loop SLOs.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 179, "line_end": 187, "atom_id": "ATOM-SOURCE-20260216-018-0016"}, "metadata": {"category": "praxis_hook", "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.3, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}}
{"record_type": "source_atom", "schema_version": "1.0.0", "uuid": "3158589a-ad2b-512d-ab4f-04c160bce8a8", "timestamp": "2026-02-24T00:44:02.129728+00:00", "payload": {"atom_id": "ATOM-SOURCE-20260216-018-0017", "source_id": "SOURCE-20260216-018", "category": "claim", "content": "Implementing the recommended pattern for repository management allows agents to implement, validate, and be reviewed with deterministic, auditable standards.", "line_start": 187, "line_end": 187, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.6, 0.4, 0.1, 0.2, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}, "source_id": "SOURCE-20260216-018", "entity_type": "Claim", "name": "Implementing the recommended pattern for repository management allows agents to", "content": "Implementing the recommended pattern for repository management allows agents to implement, validate, and be reviewed with deterministic, auditable standards.", "confidence": 1.0, "provenance": {"source_id": "SOURCE-20260216-018", "line_start": 187, "line_end": 187, "atom_id": "ATOM-SOURCE-20260216-018-0017"}, "metadata": {"category": "claim", "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.6, 0.4, 0.1, 0.2, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}}
