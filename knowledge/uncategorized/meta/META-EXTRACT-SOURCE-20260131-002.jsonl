{"atom_id": "ATOM-SOURCE-20260131-002-0001", "source_id": "SOURCE-20260131-002", "category": "praxis_hook", "content": "To give an AI agent durable, structured memory, use a three-layer approach built on Tiago Forte's PARA framework, extended with atomic facts, memory decay, and automated extraction.", "line_start": 17, "line_end": 20, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0002", "source_id": "SOURCE-20260131-002", "category": "claim", "content": "Most AI assistants have shallow memory features, often just a flat list of facts without structure, decay, or hierarchy, requiring users to repeat information constantly.", "line_start": 24, "line_end": 27, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.8, 0.1, 0.1, 0.2, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0003", "source_id": "SOURCE-20260131-002", "category": "framework", "content": "A three-layer memory architecture for personal AI assistants includes a Knowledge Graph (long-term declarative memory), Daily Notes (episodic memory), and Tacit Knowledge (procedural memory).", "line_start": 39, "line_end": 47, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.4, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0004", "source_id": "SOURCE-20260131-002", "category": "framework", "content": "The Knowledge Graph layer is a directory tree organized using Tiago Forte's PARA method, comprising 'projects' (active work), 'areas' (ongoing responsibilities), 'resources' (reference material), and 'archives' (inactive items).", "line_start": 50, "line_end": 64, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.7, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0005", "source_id": "SOURCE-20260131-002", "category": "concept", "content": "The PARA method categorizes every entity in one of four buckets (Projects, Areas, Resources, Archives), with entities naturally flowing between them over time, and nothing ever being deleted, only archived.", "line_start": 68, "line_end": 80, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.7, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0006", "source_id": "SOURCE-20260131-002", "category": "praxis_hook", "content": "For tiered retrieval in a knowledge graph, each entity should have two files: a concise `summary.md` for quick context and an `items.json` array of atomic facts for granular detail, loaded only when needed.", "line_start": 84, "line_end": 90, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0007", "source_id": "SOURCE-20260131-002", "category": "framework", "content": "The atomic fact schema includes fields like `id`, `fact`, `category` (milestone, status, preference, context), `timestamp`, `source`, `status` (active/superseded), `supersededBy` (pointer to new fact), `relatedEntities` (cross-references), `lastAccessed`, and `accessCount`.", "line_start": 94, "line_end": 114, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0008", "source_id": "SOURCE-20260131-002", "category": "praxis_hook", "content": "Implement a 'no-deletion rule' for facts: when information changes, mark the old fact as `superseded` and create a new one, preserving a full history and allowing tracing of evolution over time.", "line_start": 118, "line_end": 123, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.4, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0009", "source_id": "SOURCE-20260131-002", "category": "framework", "content": "Daily notes serve as a raw, chronological timeline of events, capturing conversation details without immediate structure, and are retained as the source-of-truth timeline after durable facts are extracted to the knowledge graph.", "line_start": 129, "line_end": 136, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0010", "source_id": "SOURCE-20260131-002", "category": "framework", "content": "Tacit knowledge is stored in a single file, capturing user patterns and preferences (communication, working style, tools, rules) that change slowly and are updated only when new patterns emerge.", "line_start": 139, "line_end": 146, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0011", "source_id": "SOURCE-20260131-002", "category": "claim", "content": "Facts with high accessCount resist decay, preventing important-but-intermittent facts from falling off the radar.", "line_start": 148, "line_end": 150, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.1, 0.1, 0.2, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0012", "source_id": "SOURCE-20260131-002", "category": "concept", "content": "Memory decay in an AI system mimics human memory by making recent and frequently-accessed information more available, implemented through recency weighting on summary files.", "line_start": 150, "line_end": 153, "chaperone": {"context_type": "hypothesis", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.3, 0.6, 0.5], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0013", "source_id": "SOURCE-20260131-002", "category": "framework", "content": "The decay model for facts is simple, using three tiers based on recency (Hot, Warm, Cold) with frequency as a modifier, without exponential curves or tunable parameters.", "line_start": 152, "line_end": 155, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0014", "source_id": "SOURCE-20260131-002", "category": "praxis_hook", "content": "Implement access tracking for memory decay: every time a fact is used, increment `accessCount` and update `lastAccessed` to create a usage signal independent of creation time.", "line_start": 157, "line_end": 161, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0015", "source_id": "SOURCE-20260131-002", "category": "praxis_hook", "content": "An automated heartbeat process should periodically scan recent conversations for new information, extract durable facts (relationships, status changes, milestones, decisions), write them to the knowledge graph, update daily notes with timeline entries, and bump access metadata on referenced facts.", "line_start": 161, "line_end": 168, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0016", "source_id": "SOURCE-20260131-002", "category": "praxis_hook", "content": "To prevent a knowledge graph from filling with one-off mentions, create an entity only if it's mentioned 3+ times, has a direct relationship to you, or is a significant project/company; otherwise, capture it in daily notes.", "line_start": 173, "line_end": 177, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0017", "source_id": "SOURCE-20260131-002", "category": "praxis_hook", "content": "Once a week, rewrite summary.md files by loading all active facts, sorting them by recency tier (Hot → Warm → Cold) and then by accessCount, writing Hot and Warm facts into summary.md, and dropping Cold facts from the summary.", "line_start": 181, "line_end": 188, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0018", "source_id": "SOURCE-20260131-002", "category": "claim", "content": "The system ensures summary.md always reflects the current mental model of an entity, not its complete history, with the full history residing in items.json.", "line_start": 190, "line_end": 191, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.2, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0019", "source_id": "SOURCE-20260131-002", "category": "concept", "content": "Separation of concerns in a knowledge system means each layer (knowledge graph for 'what', daily notes for 'when', tacit knowledge for 'how') has a clear, distinct job.", "line_start": 197, "line_end": 199, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.1, 0.1, 0.2, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0020", "source_id": "SOURCE-20260131-002", "category": "concept", "content": "Graceful degradation in a knowledge system means there are fallbacks if a component fails, e.g., if heartbeat extraction misses something, it's still in daily notes; if a summary is stale, full facts are in items.json.", "line_start": 201, "line_end": 203, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.1, 0.1, 0.2, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0021", "source_id": "SOURCE-20260131-002", "category": "claim", "content": "The system ensures no information loss through a no-deletion rule and an archive system, allowing tracing back to when something was learned and how it evolved.", "line_start": 205, "line_end": 207, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.1, 0.1, 0.2, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0022", "source_id": "SOURCE-20260131-002", "category": "claim", "content": "Tiered retrieval (summary first, then facts) improves context window efficiency by preventing the agent from loading everything it knows, as most conversations only need the summary.", "line_start": 209, "line_end": 211, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.1, 0.1, 0.2, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0023", "source_id": "SOURCE-20260131-002", "category": "claim", "content": "The system has a natural lifecycle where entities flow from Projects to Archives when complete, and facts flow from Hot to Warm to Cold as they age, making it a dynamic rather than static database.", "line_start": 213, "line_end": 215, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.1, 0.1, 0.2, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0024", "source_id": "SOURCE-20260131-002", "category": "concept", "content": "QMD is a local indexing and retrieval tool that indexes markdown files into a SQLite database and provides full-text search (BM25), vector similarity search, and combined query modes.", "line_start": 221, "line_end": 226, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0025", "source_id": "SOURCE-20260131-002", "category": "praxis_hook", "content": "To implement a knowledge system for an AI assistant, start with the directory structure (PARA folders, index.md), then create summary.md and items.json for one active project and one important person, add daily notes, automate extraction later, and add decay last.", "line_start": 257, "line_end": 266, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260131-002-0026", "source_id": "SOURCE-20260131-002", "category": "claim", "content": "The system is deliberately low-tech, using markdown files and JSON backed up to a private git repo, without a database or special tooling, to avoid vendor lock-in and ensure memory portability across AI assistants.", "line_start": 268, "line_end": 270, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.1, 0.1, 0.2, 0.8], "opposes_atom_ids": []}, "extensions": {}}
