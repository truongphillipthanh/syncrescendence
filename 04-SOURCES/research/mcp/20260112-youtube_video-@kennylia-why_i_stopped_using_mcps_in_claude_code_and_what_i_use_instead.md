[[00:00](http://www.youtube.com/watch?v=Xs2CkHEpIrM&t=0)]
**KENNY LIAO**: I have been saying this for a while, but there is a massive problem with using Model Context Protocol (MCP) servers right now, especially with Claude Code or other coding agents. That problem is how much context they take up. When I am connected to the seven MCP servers I use on a daily basis, my Claude Code context window is severely impacted. Claude's context window has a 200,000 token limit. With these seven servers, the MCP tools alone consume around 100,000 tokens, or 50% of that total capacity. This is visually represented by stacks of blue token icons taking up half of the graph.

This is a real problem because we need to give our agents access to powerful tools, but this method doesn't work well and definitely does not scale. If I added just a couple more MCP servers, I would potentially take up the entire context window, leaving me unable to chat with Claude at all. In my current setup, I am only left with about 36,000 tokens of free space to actually start a conversation. Today, I am going to show you a better way to give Claude Code access to dozens of MCP servers—potentially thousands of tools—while retaining 100% of this context.

[[02:15](http://www.youtube.com/watch?v=Xs2CkHEpIrM&t=135)]
**KENNY LIAO**: To get frontier models to do more work for us, we need to give them access to lots of tools. MCPs are the typical way to do this because they are easy to set up and give your agent instant access to hundreds of new capabilities. However, connecting them directly to Claude creates the context bloat we just discussed. Beyond just losing free space, there is another issue: context rot. As discussed in a paper published by Chroma, the performance of agents degrades as you fill up more of the context window. If the context is filled with irrelevant information, it distracts the agent and further degrades performance.

In my previous video on context engineering, I mentioned the idea of using CLI tools or scripts instead of raw MCP servers. We can tell Claude it has access to various capabilities through the terminal, effectively giving it access to thousands of tools while initially taking up only a tiny amount of tokens in the system prompt. This follows the principle of progressive disclosure: Claude only needs the specific context for a tool if it has already decided it needs that tool to perform an action. For example, if I ask Claude to look into an error in Sentry, it might only need one or two specific tools from the Sentry MCP server. By having all servers connected directly, we dilute important information by stuffing in tool definitions that are currently irrelevant.

[[06:01](http://www.youtube.com/watch?v=Xs2CkHEpIrM&t=361)]
**KENNY LIAO**: To solve this, I built something called the MCP Launchpad. It is essentially one CLI tool to rule them all. Once installed, it is available globally, and Claude Code can access it from anywhere on your system. By running the `mcpl` command, you get a help menu for usage. You can use `mcpl config` to see the `mcp.json` file and see which servers are configured, enabled, or disabled. This acts as a gateway; you can turn servers on and off depending on your needs.

The system uses a caching mechanism. When you run `mcpl list --refresh`, the Launchpad connects to every server, retrieves the tool definitions, and caches them locally. This way, you don't have to connect to the servers every time you want to browse tools. You can also use `mcpl inspect [server] [tool]` to get the full JSON schema for a specific tool. This is how Claude Code uses the Launchpad to discover tools and learn how to use them on the fly.

[[09:45](http://www.youtube.com/watch?v=Xs2CkHEpIrM&t=585)]
**KENNY LIAO**: The most powerful part of this is the search function. Since we have cached all the tool schemas, we built a semantic search using BM25. This is more advanced than a keyword search; it looks for things semantically related to your query. For example, searching `mcpl search issues` will return the top tools from both Sentry and Linear. Searching `mcpl search SQL` returns the `execute_sql` tool from Supabase. Claude doesn't have to navigate hierarchical menus; it can just search for tools based on the task it is trying to accomplish. This makes the system incredibly scalable, as searching for a specific tool takes up far less context than loading thousands of tool definitions at once.

[[16:09](http://www.youtube.com/watch?v=Xs2CkHEpIrM&t=969)]
**KENNY LIAO**: To set this up, you need Python and UV installed. You install MCP Launchpad as a UV tool using the command `uv tool install mcp-launchpad`. Once installed, you configure your MCP servers in an `mcp.json` file. It is important to name it `mcp.json` (without a leading period) to avoid colliding with Claude Code's own configuration naming conventions. You can place this file in your project directory or, preferably, in your user-level `.cloud` folder to make it available globally.

If your MCP configurations require environment variables, you can use the `${SECRET_NAME}` notation and define them in a `.env` file in the same directory. To finalize the integration, you must tell Claude Code that it has access to this CLI. I've included a `claude.md` file in the repo that you can copy into your project or global `.cloud` directory. This file contains a high-level prompt describing the Launchpad and provides example commands. I also recommend manually listing the available servers in that file so Claude doesn't have to guess what is connected.

---

[https://www.youtube.com/watch?v=Xs2CkHEpIrM](https://www.youtube.com/watch?v=Xs2CkHEpIrM)