{"atom_id": "ATOM-SOURCE-20260220-001-0001", "source_id": "SOURCE-20260220-001", "category": "praxis_hook", "content": "To build agentic software, start simple, progressively add capabilities, and verify behavior at each step.", "line_start": 7, "line_end": 7, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0002", "source_id": "SOURCE-20260220-001", "category": "framework", "content": "Agentic software can be categorized into five architectural levels: Agent with tools, Agent with storage and knowledge, Agent with memory and learning, Multi-agent teams, and Production systems.", "line_start": 9, "line_end": 14, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.2, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0003", "source_id": "SOURCE-20260220-001", "category": "concept", "content": "An agent without tools is merely an LLM capable of reasoning but unable to perform actions.", "line_start": 20, "line_end": 20, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.3, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0004", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "Tools transform an LLM into an Agent by enabling it to perform actions.", "line_start": 20, "line_end": 20, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.4, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0005", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "For a coding agent, essential tools include the ability to read files, write files, and run shell commands.", "line_start": 20, "line_end": 21, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.6, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0006", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "A Level 1 agent (Agent with tools) is stateless, meaning each run starts without memory of previous sessions or project conventions, and its knowledge is limited to the current context.", "line_start": 43, "line_end": 44, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.2, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0007", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "Level 2 agents address the statelessness of Level 1 by incorporating session storage and domain knowledge.", "line_start": 46, "line_end": 46, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.5, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0008", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "Session storage enables an agent to include recent chat history in its context window and provides a record of agent actions for auditing and analysis.", "line_start": 49, "line_end": 54, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0009", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "Knowledge integration provides agents with access to project-relevant information outside the codebase, such as architecture specs, design decisions, and meeting notes.", "line_start": 57, "line_end": 61, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0010", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "A significant amount of valuable context for coding agents exists outside the codebase, including team discussions and past decisions.", "line_start": 63, "line_end": 67, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.4, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0011", "source_id": "SOURCE-20260220-001", "category": "praxis_hook", "content": "To provide knowledge to an agent, insert documents (text, PDF, URLs) into a knowledge base, which the agent then searches for relevant chunks to add to its context (Agentic RAG).", "line_start": 96, "line_end": 98, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0012", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "Level 2 agents are suitable when an agent needs to adhere to standards it wasn't trained on or when multi-turn conversations are expected, making it a 'sweet spot' for most internal tools.", "line_start": 106, "line_end": 106, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0013", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "The transition from Level 2 to Level 3 in agentic software is crucial because Level 3 agents learn rules from experience, unlike Level 2 agents which only follow given rules.", "line_start": 108, "line_end": 109, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.5, 0.5, 0.1, 0.2, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0014", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "A Level 3 agent (Agent with memory and learning) improves its performance over time, meaning later interactions are better than earlier ones.", "line_start": 110, "line_end": 110, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.5, 0.5, 0.1, 0.2, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0015", "source_id": "SOURCE-20260220-001", "category": "praxis_hook", "content": "To enable an agent to learn and adapt to user preferences over time, provide it with `save_learning` and `search_learnings` tools. The agent can then decide what information (e.g., coding patterns, mistakes, user preferences) is worth remembering and store it in a separate knowledge base for future sessions.", "line_start": 118, "line_end": 122, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0016", "source_id": "SOURCE-20260220-001", "category": "praxis_hook", "content": "To build a user profile for an agent, enable 'Agentic Memory' so it can track and adapt to user preferences like coding style, preferred frameworks, and explanation styles over time.", "line_start": 123, "line_end": 125, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0017", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "Level 3 agents incorporate a 'Learning Machine' that enables them to decide what information to remember (e.g., coding patterns, mistakes, user preferences) and store it in a separate knowledge base for future sessions.", "line_start": 130, "line_end": 132, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.6, 0.4, 0.1, 0.3, 0.7, 0.5], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0018", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "Level 3 agents also feature 'Agentic Memory,' allowing them to build a user profile over time, including preferred coding styles, frameworks, and explanation preferences.", "line_start": 133, "line_end": 134, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.6, 0.4, 0.1, 0.3, 0.7, 0.5], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0019", "source_id": "SOURCE-20260220-001", "category": "praxis_hook", "content": "Use Level 3 agentic learning when the agent serves the same users repeatedly and needs to improve over time, such as in personal coding assistants, team tools with shared learnings, or contexts where adapting to specific user preferences is important.", "line_start": 140, "line_end": 142, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0020", "source_id": "SOURCE-20260220-001", "category": "framework", "content": "Level 4 of agentic system design involves splitting responsibilities across specialized agents coordinated by a team leader, allowing for multiple perspectives and decomposition of tasks into specialist roles.", "line_start": 145, "line_end": 146, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.4, 0.2, 0.2, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0021", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "Multi-agent teams are powerful but unpredictable because the team leader, an LLM, makes delegation decisions that can sometimes be ineffective.", "line_start": 174, "line_end": 176, "chaperone": {"context_type": "limitation", "argument_role": "limitation", "tension_vector": [0.3, 0.7, 0.4, 0.6, 0.2, 0.5], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0022", "source_id": "SOURCE-20260220-001", "category": "praxis_hook", "content": "For production systems requiring reliability, prefer explicit workflows over dynamic multi-agent teams to avoid coordination failures.", "line_start": 176, "line_end": 177, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0023", "source_id": "SOURCE-20260220-001", "category": "praxis_hook", "content": "Use Level 4 multi-agent teams when multiple perspectives are needed (e.g., code review), tasks naturally decompose into specialist roles, or in human-supervised interactive tools where a human can oversee the team's output.", "line_start": 179, "line_end": 181, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0024", "source_id": "SOURCE-20260220-001", "category": "framework", "content": "Level 5 of agentic system design involves transitioning Levels 1-4 into a production service by upgrading to production databases (e.g., PostgreSQL + PgVector), adding tracing for observability, and exposing the system as an API via a wrapper like AgentOS.", "line_start": 184, "line_end": 185, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.4, 0.2, 0.2, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0025", "source_id": "SOURCE-20260220-001", "category": "praxis_hook", "content": "Use Level 5 when an agent leaves development, requiring support for multiple users, uptime requirements, and the ability to debug production issues.", "line_start": 210, "line_end": 211, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0026", "source_id": "SOURCE-20260220-001", "category": "praxis_hook", "content": "When building agentic systems, start at Level 1 by creating the simplest agent that can solve the problem, then incrementally add capabilities only when a missing feature is clearly identified.", "line_start": 214, "line_end": 216, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0027", "source_id": "SOURCE-20260220-001", "category": "claim", "content": "Many teams prematurely adopt multi-agent architectures (Level 4) due to their impressive demos, leading to months of debugging coordination failures that a simpler single-agent approach could have avoided.", "line_start": 217, "line_end": 219, "chaperone": {"context_type": "consensus", "argument_role": "counterevidence", "tension_vector": [0.2, 0.7, 0.3, 0.2, 0.3, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260220-001-0028", "source_id": "SOURCE-20260220-001", "category": "praxis_hook", "content": "View agentic system levels as a hierarchy of capability, and only pay the cost of increased complexity when simpler approaches have demonstrably failed.", "line_start": 220, "line_end": 221, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
