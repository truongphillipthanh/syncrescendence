{"atom_id": "ATOM-SOURCE-20260218-005-0001", "source_id": "SOURCE-20260218-005", "category": "framework", "content": "PI is a toolkit for building AI agents, structured as a monorepo of layered packages: `pi-ai` for LLM communication, `pi-agent-core` for the agent loop and tool calling, `pi-coding-agent` for a full coding agent with built-in tools and persistence, and `pi-tui` for a terminal UI.", "line_start": 4, "line_end": 10, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.0, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0002", "source_id": "SOURCE-20260218-005", "category": "claim", "content": "The PI packages are the same ones that power OpenClaw.", "line_start": 11, "line_end": 11, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.0, 0.1, 0.1, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0003", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To build production-grade agentic software without vendor lock-in, understand how to compose the layered PI packages.", "line_start": 14, "line_end": 15, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.0, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0004", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "`pi-ai` is a PI package that provides a unified interface for communicating with various LLMs (Anthropic, OpenAI, Google, etc.), handling streaming, completions, tool definitions, and cost tracking.", "line_start": 29, "line_end": 31, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0005", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "`pi-agent-core` is a PI package that wraps `pi-ai` to implement an agent loop, allowing agents to define tools, call LLMs, execute tools, and feed results back until a task is complete.", "line_start": 33, "line_end": 35, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0006", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "`pi-coding-agent` is a PI package that provides a full agent runtime with built-in file tools (read, write, edit, bash), JSONL session persistence, context compaction, skills, and an extension system.", "line_start": 37, "line_end": 39, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0007", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "`pi-tui` is a PI package that offers a terminal UI library with features like differential rendering, Markdown display, multi-line editor with autocomplete, loading spinners, and flicker-free screen updates.", "line_start": 41, "line_end": 43, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0008", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To set up a PI agent project, create a directory, initialize npm, install `@mariozechner/pi-ai`, `@mariozechner/pi-agent-core`, `@mariozechner/pi-coding-agent`, `@mariozechner/pi-tui`, `chalk`, `typescript`, `@types/node`, and `tsx`, then set your API key as an environment variable (e.g., `ANTHROPIC_API_KEY`).", "line_start": 47, "line_end": 58, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0009", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To make a basic LLM call using `pi-ai`, import `getModel` and `completeSimple`, get a model instance (e.g., `getModel(\"anthropic\", \"claude-opus-4-5\")`), and then call `completeSimple` with a system prompt and user messages.", "line_start": 63, "line_end": 84, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0010", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "The `completeSimple` function in `pi-ai` returns an `AssistantMessage` object, which contains a `.content` array of typed blocks (text, thinking, toolCall), `.usage` for token counts, and `.stopReason` (e.g., \"stop\", \"toolUse\", \"length\", \"error\", \"aborted\").", "line_start": 86, "line_end": 90, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0011", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To stream LLM responses with `pi-ai`, use `streamSimple` instead of `completeSimple`, then iterate over the `stream` events, handling `text_delta` for text chunks and `done` for the final message.", "line_start": 93, "line_end": 119, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0012", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "`streamSimple` in `pi-ai` normalizes different provider streaming formats into a single set of events, including `start`, `text_start`, `text_delta`, `text_end`, `thinking_start/delta/end`, `toolcall_start/delta/end`, `done`, and `error`.", "line_start": 120, "line_end": 123, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0013", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To switch LLM providers in `pi-ai`, only change the `getModel` call (e.g., `getModel(\"openai\", \"gpt-4o\")`), ensuring the corresponding API key is set as an environment variable.", "line_start": 128, "line_end": 135, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0014", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "Custom models for self-hosted endpoints can be defined in `pi-ai` by creating a `Model` object with `id`, `name`, `api` (e.g., \"openai-completions\"), `provider`, `baseUrl`, and other configuration details.", "line_start": 137, "line_end": 151, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.0, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0015", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "The `api` field in `pi-ai` models determines which official provider SDK (e.g., OpenAI SDK, Anthropic SDK) handles the request, allowing compatibility with any endpoint supporting that SDK's API (e.g., Ollama, vLLM, Mistral for OpenAI-compatible endpoints).", "line_start": 150, "line_end": 154, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0016", "source_id": "SOURCE-20260218-005", "category": "claim", "content": "`pi-ai` uses official provider SDKs (e.g., OpenAI SDK, Anthropic SDK) under the hood, and the `api` field determines which SDK handles the request, allowing compatibility with OpenAI-compatible endpoints like Ollama or vLLM.", "line_start": 152, "line_end": 154, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0017", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "API keys for `pi-ai` are automatically resolved from environment variables based on provider name (e.g., `OPENAI_API_KEY`) or can be passed directly as an `apiKey` option in the `streamSimple` function.", "line_start": 155, "line_end": 162, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0018", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To enable extended thinking levels (e.g., \"minimal\", \"low\", \"medium\", \"high\", \"xhigh\") for models that support it (e.g., Claude, o3, Gemini 2.5) in `pi-ai`, set the `reasoning` option when calling `streamSimple`.", "line_start": 165, "line_end": 170, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0019", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "`pi-agent-core`'s `Agent` class implements the standard agent loop, managing communication with an LLM, executing tool calls made by the LLM, and feeding results back until the model stops.", "line_start": 176, "line_end": 178, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0020", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "When defining an `AgentTool` in `pi-agent-core`, pass the TypeBox schema as a generic parameter to `AgentTool<typeof schema>` to enable TypeScript to infer parameter types correctly within the `execute` function.", "line_start": 194, "line_end": 196, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0021", "source_id": "SOURCE-20260218-005", "category": "framework", "content": "An `AgentTool` in `pi-agent-core` is defined by a `name` (LLM identifier), `label` (human-readable), `description` (LLM usage instructions), `parameters` (TypeBox schema for type-safe validation), and an `execute` function that runs the tool and returns `content` (for LLM) and `details` (for UI).", "line_start": 197, "line_end": 202, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0022", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "The `onUpdate` callback within an `AgentTool`'s `execute` function allows streaming partial results during tool execution, which is useful for long-running operations.", "line_start": 203, "line_end": 204, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0023", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To create an `Agent` in `pi-agent-core`, instantiate it with an `initialState` object containing a `systemPrompt`, `model`, an array of `tools`, and a `thinkingLevel`, along with a `streamFn` (e.g., `streamSimple` from `pi-ai`) to connect to the LLM provider.", "line_start": 207, "line_end": 220, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0024", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To monitor an `Agent`'s activity in `pi-agent-core`, subscribe to its event stream and handle various event types such as `agent_start`, `message_update` (for streaming text), `tool_execution_start`, `tool_execution_end`, and `agent_end`.", "line_start": 223, "line_end": 242, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0025", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "Initiate an `Agent`'s operation by calling its `prompt` method with a user message; the agent will then autonomously manage the LLM interaction, tool execution, and result feedback loop.", "line_start": 245, "line_end": 254, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.6, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0026", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To interrupt an agent's current task and redirect it, use `agent.steer()` which delivers the message after the current tool finishes and skips remaining pending tools.", "line_start": 361, "line_end": 367, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.5, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0027", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To queue a message for an agent to process after it naturally finishes its current work without interruption, use `agent.followUp()`.", "line_start": 370, "line_end": 374, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.5, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0028", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "`steer` interrupts an agent's current work, skipping remaining tools and injecting a new message, while `followUp` queues a message to be processed after the agent completes its current tasks naturally.", "line_start": 376, "line_end": 378, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0029", "source_id": "SOURCE-20260218-005", "category": "claim", "content": "OpenClaw uses `steer` for real-time user messages (e.g., typing while the agent works) and `followUp` for programmatic chaining of tasks.", "line_start": 378, "line_end": 380, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.5, 0.1, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0030", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "An agent's configuration can be changed at any time using methods like `agent.setModel()`, `agent.setThinkingLevel()`, `agent.setSystemPrompt()`, `agent.setTools()`, and `agent.replaceMessages()`, with changes taking effect on the next turn.", "line_start": 383, "line_end": 390, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0031", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "`pi-coding-agent` is a production-ready agent built on `pi-agent-core` that includes built-in tools, session persistence, and extensibility.", "line_start": 394, "line_end": 396, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.5, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0032", "source_id": "SOURCE-20260218-005", "category": "claim", "content": "Most users should start with `pi-coding-agent` and only use `pi-agent-core` directly if they require a custom agent without the built-in coding tools or session system.", "line_start": 397, "line_end": 399, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0033", "source_id": "SOURCE-20260218-005", "category": "framework", "content": "`pi-coding-agent` includes 7 built-in tools: `read`, `bash`, `edit`, `write` (active by default as `codingTools`), and `grep`, `find`, `ls` (available but off by default).", "line_start": 402, "line_end": 404, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0034", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "The `read` tool reads file contents and images, truncating text output to 2000 lines or 50KB, and supports `offset`/`limit` for pagination.", "line_start": 409, "line_end": 410, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0035", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "The `bash` tool executes a shell command in the working directory, returning stdout and stderr truncated to the last 2000 lines or 50KB, with an optional `timeout`.", "line_start": 411, "line_end": 412, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0036", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "The `edit` tool replaces exact text in a file, requiring `oldText` to match precisely for surgical edits.", "line_start": 413, "line_end": 414, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0037", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "The `write` tool writes content to a file, creating it if it doesn't exist, overwriting if it does, and automatically creating parent directories.", "line_start": 415, "line_end": 416, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0038", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "The `grep` tool searches file contents for a regex or literal pattern, returning matching lines with file paths and line numbers, respecting `.gitignore` and using ripgrep.", "line_start": 420, "line_end": 421, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0039", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "The `find` tool searches for files by glob pattern, returning matching paths relative to the search directory and respecting `.gitignore`.", "line_start": 422, "line_end": 423, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0040", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "The `ls` tool lists directory contents, sorting entries alphabetically with a `/` suffix for directories and including dotfiles.", "line_start": 424, "line_end": 425, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0041", "source_id": "SOURCE-20260218-005", "category": "framework", "content": "Built-in tools in `pi-coding-agent` are organized into presets: `codingTools` includes `read`, `bash`, `edit`, `write` (default), and `readOnlyTools` includes `read`, `grep`, `find`, `ls` for exploration without modification.", "line_start": 427, "line_end": 430, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0042", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To create an agent session, pick a `SessionManager` factory method based on your use case (in-memory, new persistent, open specific, or continue recent) and pass the resulting manager to `createAgentSession` along with the model.", "line_start": 434, "line_end": 454, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0043", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "`createAgentSession` is used to configure an agent with a model, tools, session persistence, and settings.", "line_start": 440, "line_end": 441, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0044", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "`SessionManager.inMemory()` creates an ephemeral session that disappears when the process exits.", "line_start": 450, "line_end": 451, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0045", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "You can list existing sessions for a directory using `SessionManager.list(process.cwd())`.", "line_start": 456, "line_end": 458, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0046", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "For custom session logic, `SessionManager` provides methods like `buildSessionContext()` to reconstruct conversation, `getLeafEntry()` to get the last entry, `branch(entryId)` to fork conversation, `appendMessage(message)` to manually add messages, and `getTree()` to get the full session tree structure.", "line_start": 461, "line_end": 489, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0047", "source_id": "SOURCE-20260218-005", "category": "claim", "content": "OpenClaw uses one session file per channel thread, stored as `~/.openclaw/agents/<agentId>/sessions/<sessionId>.jsonl`, ensuring each conversation is independent and crash-safe because JSONL is append-only.", "line_start": 490, "line_end": 492, "chaperone": {"context_type": "anecdote", "argument_role": "evidence", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.5, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0048", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To create tools that operate on a specific directory, use factory functions like `createCodingTools(\"/path/to/workspace\")` or `createReadOnlyTools(\"/path/to/workspace\")` instead of the singleton pre-built tool arrays.", "line_start": 496, "line_end": 506, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0049", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "Tool factory functions accept an optional `operations` object to override underlying I/O, allowing tools to run in different environments like Docker containers, over SSH, or against virtual filesystems by providing custom `readFile`, `access`, or `exec` implementations.", "line_start": 508, "line_end": 524, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0050", "source_id": "SOURCE-20260218-005", "category": "claim", "content": "OpenClaw uses tool factories to create workspace-scoped tools for each agent, then wraps them with middleware for permission checks, image normalization, and Claude Code parameter compatibility aliases.", "line_start": 525, "line_end": 528, "chaperone": {"context_type": "anecdote", "argument_role": "evidence", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.5, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0051", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To add custom functionality beyond file operations and shell commands, define your own tools (e.g., `deployTool`) and pass them via the `customTools` array to `createAgentSession`; they will be available alongside built-in tools.", "line_start": 531, "line_end": 559, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.6, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0052", "source_id": "SOURCE-20260218-005", "category": "claim", "content": "The `pi-coding-agent` handles long conversations exceeding the model's context window through compaction, which summarizes old messages while retaining recent ones.", "line_start": 562, "line_end": 563, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.6, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0053", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "You can manually trigger compaction by calling `session.compact(\"Preserve all file paths and code changes.\")` and provide an optional string to guide what the summary should preserve; `createAgentSession` enables auto-compaction by default when the context approaches the model's window limit.", "line_start": 564, "line_end": 572, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0054", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "An extension in the `@mariozechner/pi-coding-agent` framework is a TypeScript module that exports a function receiving an `ExtensionAPI`.", "line_start": 566, "line_end": 567, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0055", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To create an extension, define a default export function that takes an `ExtensionAPI` object as an argument, allowing you to register event handlers and commands.", "line_start": 566, "line_end": 570, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.0, 0.0, 0.0, 0.0, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0056", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "Use `api.on(\"context\", ...)` to rewrite the message array before every LLM call, for example, to prune large tool results older than 10 messages and exceeding 5000 characters.", "line_start": 571, "line_end": 582, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.1, 0.1, 0.0, 0.0, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0057", "source_id": "SOURCE-20260218-005", "category": "concept", "content": "Extensions are mechanisms that modify how an agent behaves without the LLM's awareness, by hooking into lifecycle events (e.g., before LLM calls, before compaction, on tool calls, on session start) to implement logic like trimming tool results, custom summarization, permission gating, or injecting context.", "line_start": 574, "line_end": 580, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.1, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0058", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "An extension is a TypeScript module that exports a function receiving an `ExtensionAPI`, which allows it to register event handlers like `api.on(\"context\", ...)` to rewrite message arrays before LLM calls or `api.on(\"session_before_compact\", ...)` to replace default compaction logic.", "line_start": 581, "line_end": 583, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0059", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "Implement `api.on(\"session_before_compact\", ...)` to replace the default context compaction logic with custom summarization, returning a summary, `firstKeptEntryId`, and `tokensBefore`.", "line_start": 584, "line_end": 594, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.1, 0.1, 0.0, 0.0, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0060", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "Register user-facing commands (not LLM tools) using `api.registerCommand(\"commandName\", { description: \"...\", handler: async (...) => { ... } })` to provide functionality like showing session statistics.", "line_start": 596, "line_end": 604, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.1, 0.1, 0.0, 0.0, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0061", "source_id": "SOURCE-20260218-005", "category": "framework", "content": "Key extension events include `context` (rewrite messages), `session_before_compact` (customize summarization), `tool_call` (intercept tool invocations), `before_agent_start` (inject context/modify prompt), and `session_start`/`session_switch` (react to session changes).", "line_start": 606, "line_end": 608, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.0, 0.0, 0.0, 0.0, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0062", "source_id": "SOURCE-20260218-005", "category": "claim", "content": "OpenClaw utilizes extensions for context pruning (trimming oversized tool results to save tokens) and compaction safeguards (replacing default summarization with a multi-stage pipeline that preserves file operation history and tool failure data).", "line_start": 609, "line_end": 611, "chaperone": {"context_type": "anecdote", "argument_role": "evidence", "tension_vector": [0.1, 0.1, 0.0, 0.0, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0063", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To build a codebase assistant, use `@mariozechner/pi-coding-agent` to create an `AgentSession` with a specified model, `thinkingLevel`, `sessionManager` for persistence, and `customTools` like a web search tool.", "line_start": 612, "line_end": 654, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.1, 0.0, 0.0, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0064", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "Implement session persistence by creating a `SessionManager` that opens a `.jsonl` file in a dedicated session directory, ensuring conversation history is remembered across restarts.", "line_start": 645, "line_end": 649, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.1, 0.1, 0.0, 0.0, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0065", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "Attach event handlers to the agent session using `session.subscribe()` to react to events like `message_update` (for streaming assistant responses), `tool_execution_start`/`end`, `auto_compaction_start`, and `agent_end`.", "line_start": 664, "line_end": 685, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.1, 0.1, 0.0, 0.0, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0066", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "Create a Read-Eval-Print Loop (REPL) for user interaction by using `readline` to prompt for input, handling commands like 'exit' and 'new' (to reset the session), and passing user prompts to `session.prompt()`.", "line_start": 707, "line_end": 747, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.1, 0.1, 0.0, 0.0, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0067", "source_id": "SOURCE-20260218-005", "category": "claim", "content": "A persistent coding assistant can be built in approximately 120 lines of code, capable of reading files, running commands, editing code, searching the web, and remembering conversations across restarts, with full history preserved through compaction in a JSONL session tree.", "line_start": 757, "line_end": 761, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.1, 0.0, 0.0, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0068", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "To manage credentials across multiple providers and support OAuth flows in a production environment, use `AuthStorage` and `ModelRegistry` classes, as demonstrated by OpenClaw.", "line_start": 759, "line_end": 761, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0069", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "Initialize `AuthStorage` by creating an instance with a path to an `auth.json` file, and then create a `ModelRegistry` instance using this `authStorage` and a `modelsConfigPath`.", "line_start": 762, "line_end": 763, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.1, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0070", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "Create an agent session using `createAgentSession` by passing the initialized `authStorage`, `modelRegistry`, and a specific model found via `modelRegistry.find(\"ollama\", \"llama3.1:8b\")`.", "line_start": 764, "line_end": 767, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.1, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260218-005-0071", "source_id": "SOURCE-20260218-005", "category": "praxis_hook", "content": "For production use, replace a single API key with `AuthStorage` and `ModelRegistry` to manage credentials across multiple providers and support OAuth flows.", "line_start": 765, "line_end": 766, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.1, 0.0, 0.0, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
