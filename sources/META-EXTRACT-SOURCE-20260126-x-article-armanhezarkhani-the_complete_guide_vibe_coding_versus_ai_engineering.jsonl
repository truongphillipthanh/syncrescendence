{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0001", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "concept", "content": "Vibe coding is a method where a user describes their desired outcome, an AI builds it, and the user evaluates the output by running it.", "line_start": 20, "line_end": 20, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.2, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0002", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "concept", "content": "AI engineering involves working alongside an AI, understanding every decision it makes, and being able to explain any line of generated code.", "line_start": 22, "line_end": 22, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.2, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0003", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "analogy", "content": "Vibe coding is analogous to using a self-driving car, where the user sets a destination and trusts the system, without needing to know how to drive.", "line_start": 37, "line_end": 40, "chaperone": {"context_type": "anecdote", "argument_role": "evidence", "tension_vector": [0.2, 0.6, 0.1, 0.2, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0004", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "analogy", "content": "AI engineering is analogous to driving with an advanced co-pilot, where the user remains in control and understands the process, even with AI assistance.", "line_start": 42, "line_end": 46, "chaperone": {"context_type": "anecdote", "argument_role": "evidence", "tension_vector": [0.2, 0.6, 0.1, 0.2, 0.5, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0005", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "framework", "content": "A decision framework for choosing between vibe coding and AI engineering involves answering five questions: Who's using this? How long will it exist? What if it breaks? Do I need to understand the code? Business logic complexity?", "line_start": 57, "line_end": 65, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.6, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0006", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "If the answer to most of the decision framework questions (Who's using this?, How long will it exist?, What if it breaks?, Do I need to understand the code?, Business logic complexity?) points to 'Vibe Coding', then vibe code it.", "line_start": 67, "line_end": 67, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.6, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0007", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "If the answer to even one of the decision framework questions (Who's using this?, How long will it exist?, What if it breaks?, Do I need to understand the code?, Business logic complexity?) points to 'AI Engineering', then engineer it.", "line_start": 69, "line_end": 69, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.6, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0008", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "framework", "content": "Vibe coding is suitable for weekend projects, internal tools for small teams, MVPs, sales demos, landing pages, and slide decks.", "line_start": 73, "line_end": 74, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.3, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0009", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "framework", "content": "AI engineering is necessary for production applications for customers, features in existing codebases, anything involving payments, authentication/security, or projects requiring long-term maintenance.", "line_start": 76, "line_end": 77, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.3, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0010", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Vibe coding tools enable the creation of working applications through natural language descriptions, with AI generating the code and iteration occurring via descriptive changes.", "line_start": 83, "line_end": 85, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.2, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0011", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Mastering vibe coding involves effective prompting, understanding tool limitations, and knowing when to transition to AI engineering.", "line_start": 87, "line_end": 87, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0012", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Lovable.dev is a best-in-class vibe coding tool for consumer apps, MVPs, landing pages, slide decks, and design-first products, generating high-quality, full-stack code with features like database, auth, hosting, Figma import, and one-click deployment.", "line_start": 94, "line_end": 100, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0013", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Lovable.dev may struggle with complex business logic, custom integrations, and high token consumption during debugging.", "line_start": 101, "line_end": 102, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.2, 0.7, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0014", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Vercel v0 is a best-in-class vibe coding tool for UI components and rapid prototyping for developers, offering production-ready code, best-in-class component quality, and smooth deployment.", "line_start": 105, "line_end": 109, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0015", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Vercel v0 is not full-stack, lacks databases or backend logic, and is better suited as a component generator than an app builder.", "line_start": 110, "line_end": 111, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.2, 0.7, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0016", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Replit is a strong option for vibe coding, particularly for multi-language projects, education, and collaborative teams, due to its comprehensive language support, highly autonomous Replit Agent, and built-in databases and hosting.", "line_start": 114, "line_end": 118, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0017", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Replit's Agent can override user intent, pricing can be unpredictable due to credit consumption, and a 2025 incident involving an agent deleting a production database raised concerns about autonomous operations.", "line_start": 119, "line_end": 121, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.2, 0.7, 0.1, 0.6, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0018", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Bolt.new is a strong option for vibe coding, suitable for hackathons, proof of concepts, and developers seeking code ownership, offering zero setup, in-browser operation, open-source engine support for local AI models, and full code ownership.", "line_start": 124, "line_end": 128, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0019", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Bolt.new is known for a 'fix-and-break' cycle, can incur high token costs for problem-solving, and struggles with projects exceeding 15-20 components.", "line_start": 129, "line_end": 131, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.2, 0.7, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0020", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Google AI Studio is a specialized vibe coding tool for AI-heavy applications and developers within Google's ecosystem, providing access to Gemini's multimodal capabilities and free Google Cloud credits.", "line_start": 134, "line_end": 137, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0021", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Google AI Studio is not a dedicated app builder, requires more technical knowledge, and has recently tightened its free tier limits.", "line_start": 138, "line_end": 139, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.2, 0.7, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0022", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Sales teams can create custom product demos tailored to specific client scenarios using vibe coding tools, replacing generic presentations.", "line_start": 140, "line_end": 141, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.2, 0.1, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0023", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Vibe coding is effective for internal tools due to forgiving users, limited scale, and clear requirements, enabling rapid value creation.", "line_start": 144, "line_end": 144, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0024", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "A fully designed, responsive landing page can be created in 90 seconds using vibe coding, replacing a six-week spec, design, and development cycle.", "line_start": 146, "line_end": 147, "chaperone": {"context_type": "anecdote", "argument_role": "evidence", "tension_vector": [0.3, 0.2, 0.1, 0.3, 0.7, 0.5], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0025", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Vibe coding can be transformative for sales and marketing by enabling the creation of custom product demos, interactive landing pages, campaign microsites, pricing tools, and ROI calculators.", "line_start": 149, "line_end": 150, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0026", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Vibe coding allows for testing ideas and validating market demand with functional prototypes and MVPs before committing significant engineering resources.", "line_start": 150, "line_end": 152, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.2, 0.1, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0027", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Founders can use functional prototypes instead of slide decks in investor meetings to accelerate trust.", "line_start": 164, "line_end": 165, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.3, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0028", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "When vibe coding, describe the desired 'vibe' or aesthetic rather than just listing features, as AI responds well to aesthetic direction.", "line_start": 174, "line_end": 179, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.3, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0029", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Build vibe-coded applications in phases, as the AI's context window and consistency degrade with increasing complexity.", "line_start": 182, "line_end": 183, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.3, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0030", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Be explicit about constraints when prompting vibe coding tools to prevent unintended modifications to existing elements.", "line_start": 190, "line_end": 196, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.3, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0031", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Use reference points (e.g., 'Design this like a Stripe landing page') when describing aesthetics to AI, as it is more precise than describing from scratch.", "line_start": 199, "line_end": 208, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.3, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0032", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Accept 80% completion with vibe coding tools for speed; for pixel-perfect results, graduate to AI engineering or manual finishing.", "line_start": 211, "line_end": 213, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.3, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0033", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Vibe coding fails when dealing with complex business logic, security-critical applications, high-scale requirements, custom integrations, or projects exceeding 15-20 components.", "line_start": 218, "line_end": 230, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.1, 0.4, 0.1, 0.1, 0.2, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0034", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "concept", "content": "AI engineering involves professional developers using AI tools as collaborators to write, review, and ship code faster while maintaining full understanding and control.", "line_start": 235, "line_end": 237, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.3, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0035", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Claude Code is best for senior developers, complex multi-file refactors, teams with established codebases, and CI/CD automation due to its instruction-following capabilities and deep codebase understanding.", "line_start": 246, "line_end": 253, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.3, 0.1, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0036", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Cursor is highly effective for feature work and refactoring, offering an IDE-like experience with autocomplete, Composer/Agent mode for multi-file edits, and codebase indexing for context.", "line_start": 256, "line_end": 263, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.3, 0.1, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0037", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "GitHub Copilot holds a 42% market share and can lead to 55% faster task completion, with deep VS Code and GitHub integration and support for over 200 languages.", "line_start": 275, "line_end": 280, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.3, 0.1, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0038", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "GitHub Copilot has been found to produce code with security weaknesses in 29% of Python and 24% of JavaScript code, and struggles with complex architectures, with a 6.4% secret leakage rate.", "line_start": 281, "line_end": 283, "chaperone": {"context_type": "consensus", "argument_role": "counterevidence", "tension_vector": [0.1, 0.4, 0.2, 0.1, 0.2, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0039", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "AI engineering is appropriate for projects requiring maintainability, quality, and understanding, especially those destined for production or team maintenance.", "line_start": 283, "line_end": 285, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0040", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "AI can be used for refactoring and code modernization by performing mechanical transformations like updating patterns, migrating frameworks, and modernizing legacy code.", "line_start": 289, "line_end": 291, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0041", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "AI engineering is suitable for tasks requiring understanding, quality, and long-term maintainability, such as refactoring, bug fixing, writing tests, code review assistance, documentation generation, and learning new codebases.", "line_start": 292, "line_end": 309, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.3, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0042", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "AI can assist with bug fixing and debugging by explaining error messages, suggesting fixes, and tracing issues across files, with stack trace analysis being a significant time-saver.", "line_start": 293, "line_end": 295, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0043", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "AI can generate unit tests, integration tests, and edge case scenarios that align with existing test patterns.", "line_start": 297, "line_end": 299, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0044", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "AI can assist in code reviews by identifying patterns that human reviewers might miss.", "line_start": 301, "line_end": 303, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0045", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "AI can generate documentation such as comments, docstrings, README files, and API documentation.", "line_start": 305, "line_end": 307, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0046", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "AI-generated explanations can accelerate comprehension when learning new codebases.", "line_start": 309, "line_end": 311, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0047", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "AI tools like Cursor's Composer and Claude Code's agentic mode are effective for coordinating changes across multiple files.", "line_start": 313, "line_end": 315, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0048", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "An effective AI engineering workflow involves planning before prompting: writing down the goal, identifying involved files, and defining 'done' to ensure clear specifications for the AI.", "line_start": 322, "line_end": 329, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0049", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "When prompting LLMs, focus on one task at a time (e.g., implement one function, fix one bug) to avoid vague requests and inconsistent code.", "line_start": 333, "line_end": 339, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0050", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Always review AI-generated code, as LLMs are over-confident and prone to mistakes; developers are responsible for the quality of committed code.", "line_start": 343, "line_end": 349, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0051", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "A 2025 study found that developers who perceived themselves as 20% faster with AI were actually 19% slower due to time spent debugging and cleaning up AI-generated code.", "line_start": 345, "line_end": 347, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.2, 0.6, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0052", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Utilize linter feedback loops by copying errors from AI-generated code back into the chat, allowing the model to address structured error output.", "line_start": 352, "line_end": 356, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0053", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Practice Test-Driven Prompting by writing a failing test first, then asking the AI to implement the function to make that test pass, which constrains the AI's solution space and provides automatic verification.", "line_start": 359, "line_end": 363, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0054", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Start clear sessions between tasks in AI tools (e.g., using /clear in Claude Code or a new Composer session in Cursor) to prevent previous context from polluting new requests.", "line_start": 366, "line_end": 369, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0055", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Create custom commands or save prompt templates for repeated workflows, using features like Claude Code's .claude/commands/, Cursor's Notepads, or a personal prompt library.", "line_start": 372, "line_end": 376, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0056", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Blindly trusting AI output is a mistake, as AI-generated pull requests have 1.7x more major issues than human-written ones, making the review step more critical.", "line_start": 380, "line_end": 382, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0057", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Skipping code review is a mistake because 45% of AI-generated code introduces security vulnerabilities, meaning code should not be shipped if it's not understood.", "line_start": 384, "line_end": 386, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0058", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Over-prompting, or asking for too much at once, leads to hallucinations and inconsistent code.", "line_start": 388, "line_end": 390, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0059", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Not learning from the AI is a mistake; if you cannot explain the code, you should not commit it, and AI output should be used as a learning opportunity.", "line_start": 392, "line_end": 394, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0060", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Forcing AI into every task is a mistake, as sometimes typing is faster than prompting, and AI friction should not be added to simple edits.", "line_start": 396, "line_end": 398, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0061", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "AI-generated code requires extra security scrutiny, including running Static Application Security Testing (SAST), using Software Composition Analysis (SCA) for dependencies, being cautious with authentication/authorization/data validation, and never letting AI write security-critical code without expert review.", "line_start": 402, "line_end": 406, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0062", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Models are not improving at security as fast as they are improving at accuracy, indicating a known gap in AI development.", "line_start": 408, "line_end": 409, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.2, 0.5, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0063", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Graduate from vibe coding to AI engineering when a project becomes serious (e.g., has paying users), hits tool limits, requires custom integrations, necessitates code understanding, or when bugs become harder to fix than features.", "line_start": 415, "line_end": 422, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0064", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "To graduate from vibe coding to AI engineering: export code to a proper repository, set up a local development environment, read and understand existing code (using AI for explanations), add tests to capture current behavior before refactoring, refactor incrementally, and establish engineering practices like code review and CI/CD.", "line_start": 425, "line_end": 435, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0065", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "A mature approach to development involves a hybrid workflow: prototyping ideas with vibe coding and then building them with AI engineering for quality.", "line_start": 440, "line_end": 444, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0066", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Use vibe coding tools like v0 for generating UI components and then integrate them into an engineered codebase to add business logic.", "line_start": 446, "line_end": 449, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0067", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Vibe coding is suitable for one-off personal projects, internal tools, and demos that do not require production quality.", "line_start": 451, "line_end": 453, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0068", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "Start any new idea in vibe coding mode and graduate to engineering only when necessary.", "line_start": 455, "line_end": 456, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0069", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Vibe coding projects often hit context limits when exceeding 15-20 components, struggle with complex state management and authentication flows, can have rapid 'fix-and-break' cycles that consume tokens, typically lack tests, and are not suitable for production or high-security applications.", "line_start": 462, "line_end": 467, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0070", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "AI engineering has limitations: perceived speed gains may not match reality, 45% of generated code contains security vulnerabilities, AI struggles with cross-file data flow reasoning, there's a risk of skill erosion for junior developers, and models are not improving security as quickly as accuracy.", "line_start": 469, "line_end": 475, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0071", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Junior developers face a skill erosion risk due to AI assistance.", "line_start": 474, "line_end": 474, "chaperone": {"context_type": "speculation", "argument_role": "claim", "tension_vector": [0.4, 0.3, 0.1, 0.6, 0.1, 0.4], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0072", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "AI models are not improving at security at the same rate they are improving at accuracy.", "line_start": 475, "line_end": 475, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.5, 0.1, 0.5], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0073", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Both vibe coding and AI engineering face common limitations: potential outdated patterns due to training data, persistent hallucinations, and increased review requirements.", "line_start": 478, "line_end": 481, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0074", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "AI training data can lead to the propagation of outdated patterns.", "line_start": 478, "line_end": 478, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.4, 0.1, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0075", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "Hallucinations remain a significant problem for AI models.", "line_start": 479, "line_end": 479, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.3, 0.1, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0076", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "The volume of AI-generated code increases review requirements rather than decreasing them.", "line_start": 480, "line_end": 480, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.5, 0.2, 0.5], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0077", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "framework", "content": "The decision between vibe coding and AI engineering depends on who is using it (vibe for personal/team, AI engineering for paying customers), project duration (vibe for days/months, AI engineering for months/years), consequences of failure (vibe for minor, AI engineering for real consequences), need to understand code (vibe if no, AI engineering if yes), and complexity of business logic (vibe for standard, AI engineering for complex).", "line_start": 486, "line_end": 496, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0078", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "concept", "content": "Vibe coding is an approach to software development suitable for personal use or small teams, short-term projects (days to months), minor issues if it breaks, situations where code understanding is not critical, and standard business logic.", "line_start": 487, "line_end": 497, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0079", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "concept", "content": "AI engineering is an approach to software development suitable for paying customers, long-term projects (months to years), situations with real consequences if it breaks, when understanding code is necessary, and for complex business logic.", "line_start": 487, "line_end": 497, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0080", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "When vibe coding, describe the desired 'vibe' or feeling, not just features (e.g., 'feels minimal and calm' instead of 'has a sidebar').", "line_start": 514, "line_end": 514, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0081", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "When vibe coding, build in phases, starting with navigation, then content, then polish.", "line_start": 515, "line_end": 515, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0082", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "When vibe coding, explicitly state constraints to the AI, telling it what not to change.", "line_start": 516, "line_end": 516, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0083", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "When vibe coding, use reference points like existing well-known designs (e.g., 'like a Stripe landing page').", "line_start": 517, "line_end": 517, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0084", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "When vibe coding, accept 80% completion and avoid chasing perfection within the tool.", "line_start": 518, "line_end": 518, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0085", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "When AI engineering, plan thoroughly before prompting to define what 'done' looks like.", "line_start": 521, "line_end": 521, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0086", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "When AI engineering, give the AI one task at a time to ensure focused prompts and output.", "line_start": 522, "line_end": 522, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0087", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "When AI engineering, always review every line of AI-generated code before committing it.", "line_start": 523, "line_end": 523, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0088", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "When AI engineering, use linter feedback loops by pasting errors back to the AI for correction.", "line_start": 524, "line_end": 524, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0089", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "When AI engineering, practice test-driven prompting by writing tests first and having the AI implement the code.", "line_start": 525, "line_end": 525, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0090", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "A checklist for graduating a project from AI-assisted development includes exporting code to GitHub, setting up a local development environment, reading and understanding existing code, adding tests for current behavior, refactoring incrementally, and establishing CI/CD and code review.", "line_start": 528, "line_end": 534, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0091", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "The key skill in modern software development is fluency in both 'vibe coding' and 'AI engineering' approaches, not choosing one over the other.", "line_start": 539, "line_end": 539, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0092", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "analogy", "content": "Vibe coding is like a self-driving car where you enter a destination and arrive, best for prototypes, internal tools, personal projects, and demos that won't be maintained long-term.", "line_start": 541, "line_end": 543, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0093", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "analogy", "content": "AI engineering is like driving with a co-pilot, where you remain in control and the AI assists, best for production systems, team codebases, and anything requiring security, scale, or longevity.", "line_start": 545, "line_end": 547, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0094", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "The golden rule for using AI in coding is: 'Don't commit code you can't explain.'", "line_start": 558, "line_end": 558, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0095", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "If you can explain the code, the tool used to write it is irrelevant; if you cannot explain it, do not ship it.", "line_start": 560, "line_end": 561, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.2, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0096", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "praxis_hook", "content": "To build intuition on when to use each approach, vibe code your next personal project and AI engineer your next work feature, observing the strengths of each.", "line_start": 563, "line_end": 564, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering-0097", "source_id": "SOURCE-20260126-x-article-armanhezarkhani-the_complete_guide_vibe_coding_versus_ai_engineering", "category": "claim", "content": "The future of coding involves knowing when to use 'vibe coding' versus 'AI engineering' and being fluent in both.", "line_start": 566, "line_end": 566, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
