{"atom_id": "ATOM-SOURCE-20260211-004-0001", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "The architecture behind OpenClaw, a persistent AI assistant, emerges from practical problems related to sessions, personality systems, tools, permissions, gateways, context compaction, memory, command queues, heartbeats, and multi-agent routing.", "line_start": 4, "line_end": 6, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0002", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To build a persistent AI assistant, one can start with a messaging API, an LLM, and the goal of making AI useful outside the chat window.", "line_start": 14, "line_end": 16, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0003", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "Current LLM chatbots like ChatGPT or Claude in a browser are limited because they are stateless (every conversation starts from zero), passive (users must initiate interaction), isolated (cannot run commands or control apps), and single-channel (operate only in their own tab, lacking shared memory across messaging apps).", "line_start": 23, "line_end": 40, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.2, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0004", "source_id": "SOURCE-20260211-004", "category": "framework", "content": "An ideal AI assistant would live in existing messaging apps with shared memory, remember preferences and past conversations across sessions, run commands on a computer, browse the web, control a real browser, wake up on a schedule for recurring tasks, and run on personal hardware under user control.", "line_start": 44, "line_end": 51, "chaperone": {"context_type": "hypothesis", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.2, 0.8, 0.3, 0.3], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0005", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "OpenClaw is a personal AI assistant characterized by a persistent identity, tools, and presence across every channel a user employs, distinguishing it from a mere chatbot.", "line_start": 53, "line_end": 54, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.4, 0.3, 0.4, 0.5], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0006", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "A basic AI bot can be created using Python with the `anthropic` client and `telegram.ext` library to handle messages, where user input is sent to an LLM and its response is sent back to the user.", "line_start": 58, "line_end": 74, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0007", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "A simple AI bot without session management is comparable to a worse version of a web interface for an LLM, lacking memory and tools.", "line_start": 78, "line_end": 78, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.2, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0008", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To enable persistent sessions for an AI bot, conversation history for each user should be stored on disk, for example, in a JSONL file, and loaded before each interaction, with new messages appended to the session.", "line_start": 84, "line_end": 140, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0009", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "The JSONL format, where each line is a single message, is suitable for session transcripts because it is append-only, ensuring data integrity even if the process crashes mid-write.", "line_start": 153, "line_end": 155, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0010", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "In OpenClaw, each session corresponds to a file, and each file represents a conversation, allowing persistence across process restarts.", "line_start": 156, "line_end": 158, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0011", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "A problem with persistent sessions is that conversations grow and will eventually exceed the LLM's context window.", "line_start": 160, "line_end": 160, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.1, 0.8, 0.1, 0.6, 0.2, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0012", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To add personality to an AI bot, a markdown file (e.g., SOUL.md) can define the agent's identity, behavior, and boundaries, which is then injected as the system prompt for every API call to the LLM.", "line_start": 166, "line_end": 210, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0013", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To inject personality into an AI assistant, define its 'SOUL' (system prompt) and inject it into every API call to the language model.", "line_start": 199, "line_end": 201, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0014", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "For OpenClaw agents, the 'SOUL.md' file located at `~/.openclaw/workspace/SOUL.md` is loaded at session start and injected into the system prompt, allowing customization of the agent's origin story, philosophy, and behavioral rules.", "line_start": 203, "line_end": 210, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.1, 0.7, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0015", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "In OpenClaw, the SOUL.md file resides in the agent's workspace at `~/.openclaw/workspace/SOUL.md`.", "line_start": 212, "line_end": 212, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0016", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "The more specific an AI's 'SOUL' (system prompt), the more consistent its behavior will be.", "line_start": 212, "line_end": 212, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.6, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0017", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "A 'SOUL' for an AI assistant is a detailed system prompt that provides specific behavioral guidelines, such as \"Be the assistant you'd actually want to talk to. Concise when needed, thorough when it matters. Not a corporate drone. Not a sycophant. Just... good.\", to ensure consistent and desired behavior.", "line_start": 212, "line_end": 215, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.1, 0.7, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0018", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "A bot that can only talk is limited; adding tools allows it to perform actions.", "line_start": 219, "line_end": 220, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.9, 0.1, 0.1, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0019", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To enable an AI to 'do things', provide it with structured tools, each having a name, description, and an `input_schema` (e.g., `run_command`, `read_file`, `write_file`, `web_search`), and let the AI decide when to use them.", "line_start": 222, "line_end": 259, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0020", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "Implement an `execute_tool` function that takes a tool `name` and `input` and performs the corresponding action, such as running shell commands, reading/writing files, or performing web searches.", "line_start": 261, "line_end": 286, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0021", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To integrate tools into an AI agent's workflow, implement an agent loop (`run_agent_turn`) where the AI's response is checked for tool use; if tools are used, execute them and feed the results back to the AI as a new user message.", "line_start": 290, "line_end": 339, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0022", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "Update the message handling function (`handle_message`) to use the agent loop (`run_agent_turn`) instead of directly calling the API, allowing the AI to decide on tool usage and synthesize responses.", "line_start": 342, "line_end": 348, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0023", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "An AI can decide which tools to use, in what order, and synthesize results into a natural response, even through a messaging interface like Telegram, when provided with structured tools and an agent loop.", "line_start": 350, "line_end": 355, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.8, 0.1, 0.1, 0.8, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0024", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "Executing commands from messaging platforms like Telegram via an AI bot is dangerous due to the risk of malicious commands (e.g., `rm -rf /`) if unauthorized users gain access.", "line_start": 359, "line_end": 360, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.9, 0.1, 0.1, 0.8, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0025", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "Implement a permission system for AI agents that execute commands, such as OpenClaw's approval allowlist, to mitigate security risks.", "line_start": 362, "line_end": 362, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0026", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "Define `SAFE_COMMANDS` (e.g., `ls`, `cat`, `head`) and `DANGEROUS_PATTERNS` (e.g., `rm`, `sudo`, `chmod`) to categorize commands for a permission system.", "line_start": 366, "line_end": 367, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0027", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "Implement functions to load and save command approvals to a persistent file (e.g., `exec-approvals.json`) to maintain an allowlist of approved commands.", "line_start": 370, "line_end": 382, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0028", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "Implement command safety checks by defining a set of `SAFE_COMMANDS` and `DANGEROUS_PATTERNS` (e.g., `rm`, `sudo`, `chmod`, `curl | sh`). Use a `check_command_safety` function to classify commands as 'safe', 'approved', or 'needs_approval'. For 'needs_approval' commands, block execution and return a permission denied message.", "line_start": 391, "line_end": 435, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.0, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0029", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "Persist command approval decisions to a file (e.g., `exec-approvals.json`) to avoid re-prompting for the same command. Implement `load_approvals` and `save_approval` functions to manage this persistent allowlist.", "line_start": 437, "line_end": 460, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.0, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0030", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "OpenClaw extends basic command safety with glob patterns (e.g., `git *`), and a three-tier approval model: 'ask' (prompt user), 'record' (log but allow), and 'ignore' (auto-allow).", "line_start": 480, "line_end": 483, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.5, 0.0, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0031", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "A 'gateway' is a central process that manages multiple communication channels (e.g., Discord, WhatsApp, Slack) for an AI, allowing shared sessions, memory, and configurations across platforms.", "line_start": 490, "line_end": 495, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.5, 0.0, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0032", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "The `run_agent_turn` function is decoupled from specific communication channels, as it only processes messages and returns text, making it suitable for integration into a gateway pattern.", "line_start": 499, "line_end": 501, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.1, 0.6, 0.0, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0033", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To implement a gateway pattern, run an HTTP API (e.g., using Flask) in a background thread alongside an existing bot (e.g., Telegram). Both interfaces should interact with the same agent logic and session management functions (`load_session`, `save_session`, `run_agent_turn`) to share state.", "line_start": 503, "line_end": 535, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.5, 0.0, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0034", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "OpenClaw's gateway manages multiple channels (Telegram, Discord, WhatsApp, Slack, Signal, iMessage) via a single config file and supports configurable session scoping (per-user, per-channel, or shared).", "line_start": 547, "line_end": 551, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.5, 0.0, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0035", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To address the growing session problem in AI conversations, implement 'context compaction' by summarizing old messages when the total token count exceeds a threshold. This involves splitting the message history, summarizing the older half using an LLM, and replacing it with a concise summary.", "line_start": 557, "line_end": 581, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.5, 0.0, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0036", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To test session compaction without extensive chatting, temporarily lower the token threshold for compaction, for example, to `if estimate_tokens(messages) < 1000:`.", "line_start": 569, "line_end": 571, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.2, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0037", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "OpenClaw's compaction method is more sophisticated than a simple token threshold, involving splitting messages into token-based chunks, summarizing each chunk separately, and including a safety margin for estimation inaccuracies.", "line_start": 577, "line_end": 580, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0038", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "Long-term memory in an agent system refers to persistent knowledge that survives session resets, allowing the agent to recall context from previous interactions.", "line_start": 585, "line_end": 586, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.2, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0039", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "Implement long-term memory by giving the agent `save_memory` and `memory_search` tools that store and retrieve information from files.", "line_start": 587, "line_end": 588, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0040", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To save memory, create a directory (e.g., `./memory`), and write the content to a file within that directory, using the provided key as part of the filename (e.g., `key.md`).", "line_start": 620, "line_end": 624, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0041", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To search memory, iterate through files in the memory directory, read their content, and check if any words from the query are present in the content (case-insensitive).", "line_start": 626, "line_end": 634, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0042", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "Update the agent's SOUL (system prompt) to inform it about the long-term memory system, instructing it to use `save_memory` for important information and `memory_search` at the start of conversations.", "line_start": 637, "line_end": 644, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0043", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "The memory system persists because it stores information in files rather than within the session, allowing it to survive session resets or bot restarts.", "line_start": 655, "line_end": 656, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.2, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0044", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "OpenClaw's production memory system uses vector search with embeddings for semantic matching, which is more advanced than keyword search.", "line_start": 658, "line_end": 659, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.3, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0045", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "A command queue, implemented with a per-session lock, prevents data corruption when multiple messages arrive simultaneously for the same user by ensuring only one message is processed at a time for that session, while allowing different sessions to run in parallel.", "line_start": 665, "line_end": 667, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.2, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0046", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "Implement a per-session lock by using `collections.defaultdict(threading.Lock)` and wrapping the message handling logic (e.g., in `handle_message` or `/chat` endpoint) with `with session_locks[user_id]:`.", "line_start": 670, "line_end": 699, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0047", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "OpenClaw extends the command queue with lane-based queues for messages, cron jobs, and sub-agents to prevent heartbeats from blocking real-time conversations.", "line_start": 703, "line_end": 704, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.3, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0048", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "Heartbeats are recurring tasks that trigger an agent on a timer, enabling scheduled execution for actions like checking email or summarizing calendars.", "line_start": 709, "line_end": 710, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.2, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0049", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To set up heartbeats, use a scheduling library (e.g., `schedule`) to define recurring tasks that call a function, which in turn triggers the agent with a specific message.", "line_start": 714, "line_end": 715, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0050", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "For heartbeats, use an isolated session key (e.g., `cron:morning-briefing`) to prevent scheduled tasks from cluttering the main chat session history.", "line_start": 720, "line_end": 721, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0051", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "Run the scheduler for heartbeats in a background thread to ensure it operates continuously without blocking the main application.", "line_start": 732, "line_end": 736, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0052", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "The heartbeat mechanism works by calling the same `run_agent_turn` function as regular messages, but its trigger is a timer instead of human input.", "line_start": 742, "line_end": 743, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.2, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0053", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "OpenClaw supports full cron expressions for scheduling and routes heartbeats through a separate command queue lane to avoid blocking real-time messages.", "line_start": 754, "line_end": 755, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.3, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0054", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To test a scheduled agent heartbeat, temporarily change its schedule to run every minute.", "line_start": 769, "line_end": 771, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.1, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0055", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "OpenClaw supports full cron expressions (e.g., `30 7 * * *`) for scheduling tasks.", "line_start": 775, "line_end": 775, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.2, 0.1, 0.1, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0056", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "OpenClaw routes heartbeats through a separate command queue lane to prevent them from blocking real-time messages.", "line_start": 775, "line_end": 776, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.2, 0.1, 0.1, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0057", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "A single AI agent personality and toolset may not be sufficient to cover all tasks effectively as complexity increases.", "line_start": 782, "line_end": 783, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.7, 0.1, 0.1, 0.2, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0058", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To handle diverse tasks, implement multiple agent configurations with routing, where each agent has its own SOUL and session, and messages are switched between them based on content.", "line_start": 785, "line_end": 786, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0059", "source_id": "SOURCE-20260211-004", "category": "framework", "content": "An agent configuration can be defined by its name, SOUL (system prompt), and a session prefix.", "line_start": 787, "line_end": 799, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0060", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "Implement a `resolve_agent` function to route messages to the correct agent based on prefix commands (e.g., `/research`).", "line_start": 801, "line_end": 806, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0061", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "In a multi-agent system, each agent maintains its own conversation history but can share a common memory directory for collaboration.", "line_start": 830, "line_end": 831, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.1, 0.6, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0062", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "OpenClaw extends multi-agent systems with sub-agent spawning and inter-agent messaging, but the core pattern remains SOUL + session + tools.", "line_start": 834, "line_end": 835, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.5, 0.5, 0.1, 0.1, 0.6, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0063", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "A mini-OpenClaw implementation (approximately 400 lines of code) can combine sessions, SOUL, tools, permissions, compaction, memory, command queue, cron, and multi-agent routing into a single runnable REPL script.", "line_start": 840, "line_end": 842, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0064", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "The memory in a mini-OpenClaw system persists across sessions, and agents collaborate through shared memory files.", "line_start": 873, "line_end": 873, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0065", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "Persistent sessions (using JSONL files) provide crash-safe conversation memory, where each session is one file and each line is one message, allowing the system to retain state after restarts.", "line_start": 880, "line_end": 881, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.6, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0066", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "SOUL.md (system prompt) is a personality file that transforms a generic AI into a specific agent with consistent behavior, boundaries, and style.", "line_start": 883, "line_end": 884, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.7, 0.1, 0.1, 0.6, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0067", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "The Tools + Agent loop involves structured tool definitions that enable the AI to decide when to act, calling the LLM, executing requested tools, feeding results back, and repeating until a task is complete.", "line_start": 886, "line_end": 888, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.7, 0.1, 0.1, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0068", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "Permission controls involve an allowlist of safe commands and persistent approvals, ensuring dangerous operations require explicit consent.", "line_start": 890, "line_end": 891, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0069", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "The gateway pattern uses one central agent with multiple interfaces (e.g., Telegram, HTTP), all communicating with the same sessions and memory.", "line_start": 893, "line_end": 894, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.1, 0.6, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0070", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "Context compaction summarizes old messages and retains recent ones when conversations exceed the context window, allowing the bot to maintain knowledge without hitting token limits.", "line_start": 896, "line_end": 897, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.7, 0.1, 0.1, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0071", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "Long-term memory, implemented as file-based storage with save and search tools, provides knowledge that survives session resets and is accessible to any agent.", "line_start": 899, "line_end": 900, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.7, 0.1, 0.1, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0072", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "A command queue uses per-session locking to prevent race conditions when multiple messages arrive simultaneously.", "line_start": 902, "line_end": 903, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0073", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "Heartbeats are scheduled agent runs on a timer, each with its own isolated session, allowing the agent to perform tasks automatically and then return to an idle state.", "line_start": 905, "line_end": 906, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.7, 0.1, 0.1, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0074", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To prevent race conditions when multiple messages arrive simultaneously for an AI agent, implement per-session locking using a command queue.", "line_start": 905, "line_end": 906, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0075", "source_id": "SOURCE-20260211-004", "category": "concept", "content": "Multi-agent routing involves multiple agent configurations with different SOULs and session keys, routed by message content, enabling agents to collaborate through shared memory files.", "line_start": 908, "line_end": 909, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.7, 0.1, 0.1, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0076", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To enable an AI agent to perform tasks automatically on a timer, schedule agent runs as 'heartbeats,' where each run uses an isolated session, performs its task, and then goes back to sleep.", "line_start": 908, "line_end": 909, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0077", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To allow multiple AI agents with different configurations (SOULs and session keys) to collaborate, route messages based on content and enable agents to share memory files.", "line_start": 911, "line_end": 912, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0078", "source_id": "SOURCE-20260211-004", "category": "claim", "content": "The development of specific AI agent features like sessions, SOUL.md, tools, permission controls, gateway, compaction, memory, command queue, heartbeats, and multi-agent routing emerged from practical problems encountered during AI development.", "line_start": 914, "line_end": 929, "chaperone": {"context_type": "anecdote", "argument_role": "evidence", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.5, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-004-0079", "source_id": "SOURCE-20260211-004", "category": "praxis_hook", "content": "To enable an AI agent to 'see' the web without incurring high token costs from screenshots, use semantic snapshots, which are text representations of a webpage's accessibility tree, providing interactive elements with numbered reference IDs.", "line_start": 936, "line_end": 944, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
