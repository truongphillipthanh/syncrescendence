{"atom_id": "ATOM-SOURCE-20260205-009-0001", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "Context graphs are considered a \"trillion-dollar opportunity\" by investors like @JayaGup10 and @ashugarg in enterprise AI.", "line_start": 3, "line_end": 4, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.0, 0.2, 0.1, 0.2], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0002", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "AI models currently lack the process knowledge required to reliably automate work, despite being able to use tools.", "line_start": 6, "line_end": 7, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.1, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0003", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "Systems of record capture decisions, but the actual work often occurs in less structured environments like meetings, chats, emails, and documents.", "line_start": 7, "line_end": 8, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.1, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0004", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "Without a structured understanding of how work is performed, AI cannot reliably automate it.", "line_start": 8, "line_end": 9, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.7, 0.0, 0.1, 0.1, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0005", "source_id": "SOURCE-20260205-009", "category": "concept", "content": "A context graph is a model that connects enterprise entities (people, documents, tickets, systems) with the temporal traces of actions and events between them, surfacing actionable insights for AI to understand how work is done.", "line_start": 19, "line_end": 21, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.0, 0.2, 0.4, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0006", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "Current AI agents struggle with end-to-end processes or long-term tasks (spanning weeks or months) that necessitate synthesizing knowledge from multiple, disparate systems.", "line_start": 30, "line_end": 32, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.6, 0.0, 0.1, 0.1, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0007", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "Systems of record typically only display the current state and rarely capture execution variability or full historical context, leading to blind spots and suboptimal outcomes if relied upon solely.", "line_start": 35, "line_end": 38, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.1, 0.6, 0.0, 0.1, 0.1, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0008", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "An internal model of an organization's real processes, built from actual traces of actions (a context graph), serves as the best proxy for learning both the structure to follow and the intent behind the work.", "line_start": 40, "line_end": 42, "chaperone": {"context_type": "hypothesis", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.0, 0.3, 0.4, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0009", "source_id": "SOURCE-20260205-009", "category": "concept", "content": "A context graph describes the flow of work by modeling 'how' change happens (behavior: who did what, in which apps, in what order, and with what effect) rather than just 'what' exists (traditional data and knowledge systems modeling things like customers, tickets, docs, people, systems).", "line_start": 45, "line_end": 50, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.0, 0.2, 0.4, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0010", "source_id": "SOURCE-20260205-009", "category": "framework", "content": "In a context graph, 'actions' are first-class entities, represented as nodes (e.g., 'created,' 'viewed,' 'approved,' 'escalated,' 'commented on,' 'resolved' with timestamps and metadata) and edges representing causality and correlation (e.g., 'Message A' triggered 'Update B' at probability P).", "line_start": 52, "line_end": 57, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.0, 0.2, 0.4, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0011", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "Modeling actions as first-class entities in a context graph allows for attaching predictive power to activity sequences, enabling suggestions for the next likely step without hard-coding flows.", "line_start": 59, "line_end": 61, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.0, 0.6, 0.5, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0012", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "Layered on process paths, derived insights explain why one path differed from another, encoding a probable 'why' that can be fed to an agent at runtime.", "line_start": 64, "line_end": 66, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.0, 0.3, 0.5, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0013", "source_id": "SOURCE-20260205-009", "category": "praxis_hook", "content": "After an agent runs, its actions should become new traces for the context graph, allowing reinforcement learning to evaluate path optimality and identify future alternative paths.", "line_start": 68, "line_end": 70, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.4, 0.0, 0.4, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0014", "source_id": "SOURCE-20260205-009", "category": "praxis_hook", "content": "Building a context graph requires a foundation of deep connectors and observability, integrating at a document level with apps where work occurs (CRM, ticketing, chat, docs, email, calendars, code, dashboards, internal apps) and structured data.", "line_start": 74, "line_end": 78, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.0, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0015", "source_id": "SOURCE-20260205-009", "category": "praxis_hook", "content": "To build a context graph, capture all change events in an application, normalize them, and expose them as traces.", "line_start": 85, "line_end": 87, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.0, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0016", "source_id": "SOURCE-20260205-009", "category": "praxis_hook", "content": "After crawling and indexing data, build a knowledge graph by running a machine learning pipeline to infer higher-level entities (projects, customers, products, teams, people) and their relationships (which docs, tickets, calls, dashboards belong to a given product or account).", "line_start": 90, "line_end": 94, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.0, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0017", "source_id": "SOURCE-20260205-009", "category": "praxis_hook", "content": "To analyze processes in aggregate, normalize personal graphs into sequences of anonymized steps, including action type, tool family, knowledge graph entities, derived process tags, and lightweight timing features/outcomes.", "line_start": 90, "line_end": 99, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0018", "source_id": "SOURCE-20260205-009", "category": "praxis_hook", "content": "Continuously feed activity signals (views, edits, comments) into the knowledge graph to understand information usage and collaboration patterns, enabling the system to recognize that entities like 'ACME Inc' in CRM and 'ACME' in support tickets refer to the same customer.", "line_start": 96, "line_end": 99, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.0, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0019", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "Knowledge graphs are a key foundation for context graphs because activity signals alone are noisy and require the underlying knowledge graph to make them meaningful.", "line_start": 101, "line_end": 102, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.0, 0.1, 0.3, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0020", "source_id": "SOURCE-20260205-009", "category": "praxis_hook", "content": "When abstracting process traces, exclude raw text (doc bodies, message text), user identifiers, or customer-specific secrets to preserve anonymity.", "line_start": 101, "line_end": 102, "chaperone": {"context_type": "method", "argument_role": "limitation", "tension_vector": [0.1, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0021", "source_id": "SOURCE-20260205-009", "category": "praxis_hook", "content": "Compute similarity between abstracted traces to identify processes that are likely the same.", "line_start": 102, "line_end": 103, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0022", "source_id": "SOURCE-20260205-009", "category": "praxis_hook", "content": "Only consider a process pattern viable if it appears across at least 'k' distinct users and 'n' independent traces, dropping anything too rare to preserve anonymity.", "line_start": 105, "line_end": 106, "chaperone": {"context_type": "method", "argument_role": "limitation", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0023", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "The system's context graph, which agents use as playbooks, is built by probabilistically viewing \"what tends to happen,\" \"in what order,\" and \"why paths deviate,\" with timing used to determine process value (e.g., longer time for similar user groups suggests high value).", "line_start": 108, "line_end": 112, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0024", "source_id": "SOURCE-20260205-009", "category": "framework", "content": "A hybrid model for storing event data uses free-form text broken into smaller chunks with embedded entity IDs, rather than rigid pure graph structures or flexible but hard-to-navigate raw text.", "line_start": 114, "line_end": 116, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0025", "source_id": "SOURCE-20260205-009", "category": "praxis_hook", "content": "To enable agents to walk a process step-by-step, break down incidents into short segments marking transitions (e.g., \"investigating\" to \"mitigating\") by tagging them with IDs like incident_id=INC-123, channel_id=#p1-incidents, or action_type=escalated.", "line_start": 118, "line_end": 121, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0026", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "The method of tagging incident transitions with IDs is not optimized for reasoning across thousands of incidents at once.", "line_start": 121, "line_end": 122, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.1, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0027", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "If agents run within the system, every agent run becomes a trace that the graph learns from, including tools called, order, inputs/outputs, success, efficiency, and user feedback.", "line_start": 125, "line_end": 129, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0028", "source_id": "SOURCE-20260205-009", "category": "praxis_hook", "content": "Agent learnings are scoped per enterprise and focus on how the agent uses tools, not on storing underlying content.", "line_start": 131, "line_end": 132, "chaperone": {"context_type": "method", "argument_role": "limitation", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0029", "source_id": "SOURCE-20260205-009", "category": "praxis_hook", "content": "Offline, replay agent traces and try alternative routes, scoring them on correctness, completeness, instruction following, and efficiency.", "line_start": 134, "line_end": 135, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260205-009-0030", "source_id": "SOURCE-20260205-009", "category": "claim", "content": "Successful agent runs reinforce desired patterns, becoming natural language playbooks, while runs needing intervention highlight anti-patterns requiring more context or better tool use.", "line_start": 137, "line_end": 139, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
