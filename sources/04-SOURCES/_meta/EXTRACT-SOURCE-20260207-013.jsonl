{"atom_id": "ATOM-SOURCE-20260207-013-0001", "source_id": "SOURCE-20260207-013", "category": "praxis_hook", "content": "To shape and build a small project from 0-1 using Claude Code, start by describing your vision in a new blank directory, then explicitly ask Claude to use its 'shaping skill' to capture requirements and separate problem from solution, using terminology like 'solution A' to allow for iteration.", "line_start": 4, "line_end": 29, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.5, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0002", "source_id": "SOURCE-20260207-013", "category": "concept", "content": "The 'shaping skill' in Claude Code involves separating problem and solution to allow for iterative development, using terms like 'solution A' for different potential approaches.", "line_start": 31, "line_end": 35, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.3, 0.1, 0.1, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0003", "source_id": "SOURCE-20260207-013", "category": "praxis_hook", "content": "When using Claude Code for project shaping, after the initial prompt, review the generated `shaping.md` document which includes a problem/outcome frame, extracted requirements (R), and an initial solution shape (A) with flagged unknowns.", "line_start": 43, "line_end": 64, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.4, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0004", "source_id": "SOURCE-20260207-013", "category": "concept", "content": "In the context of Claude Code's shaping skill, 'R' refers to requirements, which are ideally general enough to apply to any solution, while 'A' refers to a specific solution shape, comprising high-level 'moving parts' or mechanics.", "line_start": 54, "line_end": 64, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.4, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0005", "source_id": "SOURCE-20260207-013", "category": "praxis_hook", "content": "To check the fit between requirements (R) and a solution shape (A) in Claude Code, use the shorthand 'show me R x A' to get a fit check table that indicates solved and unsolved parts, providing a jumping-off point for further iteration.", "line_start": 66, "line_end": 72, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.4, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0006", "source_id": "SOURCE-20260207-013", "category": "concept", "content": "A 'fit check' in the shaping terminology used with Claude Code is a comparison between requirements (R) and a proposed solution shape (A) to identify what is solved, unsolved, known, and unknown.", "line_start": 69, "line_end": 72, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.4, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0007", "source_id": "SOURCE-20260207-013", "category": "concept", "content": "A 'spike' is an engineering term referring to an investigation into a question to gather concrete information about possibilities and implementation methods.", "line_start": 69, "line_end": 72, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.0, 0.0, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0008", "source_id": "SOURCE-20260207-013", "category": "praxis_hook", "content": "To understand a solution shape (A) better in Claude Code, you can 'rotate the fit check' by asking 'show me A x R', which displays all parts of A against all R, often with commentary suggesting next steps.", "line_start": 77, "line_end": 81, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.4, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0009", "source_id": "SOURCE-20260207-013", "category": "praxis_hook", "content": "When conducting a 'spike' investigation, the findings should be documented as a separate markdown file for reference and inspection.", "line_start": 78, "line_end": 80, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.0, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0010", "source_id": "SOURCE-20260207-013", "category": "claim", "content": "A timezone library that is local and correctly handles DST rules eliminates the need to fetch timezone data from the internet on every load, as the data is accurate by design.", "line_start": 91, "line_end": 94, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.0, 0.1, 0.3, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0011", "source_id": "SOURCE-20260207-013", "category": "praxis_hook", "content": "The primary rule of spiking is to ensure it's not a yes-or-no question; a spike should aim to gather objective information for decision-making.", "line_start": 109, "line_end": 111, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.0, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0012", "source_id": "SOURCE-20260207-013", "category": "praxis_hook", "content": "For V1 of a project, prioritizing an LLM-only approach can simplify the implementation.", "line_start": 130, "line_end": 130, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.0, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0013", "source_id": "SOURCE-20260207-013", "category": "framework", "content": "A concrete shape 'A' for an application can be broken down into parts such as: TUI shell, mechanism using zoneinfo, hour table builder, default config, LLM input handler with tool definitions, and tool executor with validation.", "line_start": 137, "line_end": 140, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.0, 0.1, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0014", "source_id": "SOURCE-20260207-013", "category": "praxis_hook", "content": "In larger or more complex projects, it is important to create 'vertical slices' (subsets of the project with both backend and frontend) to allow for demoing and verification of direction, avoiding churn and interdependent decisions.", "line_start": 152, "line_end": 157, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.0, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0015", "source_id": "SOURCE-20260207-013", "category": "concept", "content": "A 'breadboard' is a technical diagram that combines UI and code into a single circuit-like representation, useful for visualizing and slicing larger projects into vertical slices.", "line_start": 159, "line_end": 162, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.4, 0.0, 0.2, 0.7, 0.5], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0016", "source_id": "SOURCE-20260207-013", "category": "praxis_hook", "content": "A CLI tool named `beam` can be used to find Mermaid code in a Markdown file and project it to a local TLDraw instance, allowing for hot-reloading and visual inspection of diagrams generated by an LLM.", "line_start": 164, "line_end": 167, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.7, 0.2, 0.1, 0.1, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0017", "source_id": "SOURCE-20260207-013", "category": "concept", "content": "In the context of system design, 'affordances' refer to either UI affordances (actions a user can take) or code affordances (actions the system can perform).", "line_start": 185, "line_end": 185, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.4, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0018", "source_id": "SOURCE-20260207-013", "category": "framework", "content": "A system's wiring can be formally defined as a table of 'wire' relationships between the IDs of its affordances, enabling an LLM to slice the system by defining a slice as a subset of affordances while maintaining wiring integrity.", "line_start": 185, "line_end": 189, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0019", "source_id": "SOURCE-20260207-013", "category": "praxis_hook", "content": "When an LLM-generated application crashes, instruct the LLM to run the app itself and interact with it to verify functionality across various test cases (e.g., \"add brazil\", \"feb 12\", \"paris feb 18\").", "line_start": 218, "line_end": 221, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.7, 0.2, 0.1, 0.1, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-013-0020", "source_id": "SOURCE-20260207-013", "category": "claim", "content": "Following a structured design process with an LLM, even for simple applications, provides a deeper understanding of the system's workings and rationale, facilitating future improvements and changes.", "line_start": 229, "line_end": 234, "chaperone": {"context_type": "anecdote", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.2, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
