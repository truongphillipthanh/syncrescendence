{"atom_id": "ATOM-SOURCE-20260217-016-0001", "source_id": "SOURCE-20260217-016", "category": "claim", "content": "Harness engineering improved a coding agent's performance from Top 30 to Top 5 on Terminal Bench 2.0 by solely changing the harness, not the underlying model.", "line_start": 4, "line_end": 5, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0002", "source_id": "SOURCE-20260217-016", "category": "concept", "content": "Harness Engineering involves building tooling around a model to optimize goals like task performance, token efficiency, and latency, by making design decisions about the system prompt, tool choice, and execution flow.", "line_start": 9, "line_end": 11, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.2, 0.2, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0003", "source_id": "SOURCE-20260217-016", "category": "praxis_hook", "content": "To improve agents, use traces (e.g., LangChain Traces) to understand agent failure modes at scale by observing inputs and outputs in text space, which then informs improvement loops.", "line_start": 14, "line_end": 17, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0004", "source_id": "SOURCE-20260217-016", "category": "claim", "content": "The deepagents-cli coding agent improved by 13.7 points (from 52.8% to 66.5%) on Terminal Bench 2.0 by only tweaking its harness, while keeping the gpt-5.2-codex model fixed.", "line_start": 18, "line_end": 20, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0005", "source_id": "SOURCE-20260217-016", "category": "framework", "content": "Key 'knobs' for optimizing an agent harness include the System Prompt, Tools, and Middleware (hooks around model and tool calls).", "line_start": 33, "line_end": 35, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.2, 0.2, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0006", "source_id": "SOURCE-20260217-016", "category": "praxis_hook", "content": "A 'Trace Analyzer Skill' can be used to iteratively improve an agent's harness by: 1) fetching experiment traces, 2) spawning parallel error analysis agents to synthesize findings, and 3) aggregating feedback to make targeted harness changes.", "line_start": 40, "line_end": 43, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0007", "source_id": "SOURCE-20260217-016", "category": "analogy", "content": "The Trace Analyzer Skill's approach of focusing on mistakes from previous runs to make improvements is similar to 'boosting' in machine learning.", "line_start": 44, "line_end": 45, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.3, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0008", "source_id": "SOURCE-20260217-016", "category": "praxis_hook", "content": "To improve agent performance in environments where time is a constraint, inject time budget warnings to encourage agents to finish work and shift to verification, as agents are typically poor at time estimation.", "line_start": 47, "line_end": 51, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0009", "source_id": "SOURCE-20260217-016", "category": "claim", "content": "Automated trace analysis saves significant time and facilitates rapid experimentation for agent improvement.", "line_start": 48, "line_end": 49, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0010", "source_id": "SOURCE-20260217-016", "category": "claim", "content": "Agents perform better when they have more knowledge about their environment, constraints, and evaluation criteria, enabling them to self-direct their work autonomously.", "line_start": 52, "line_end": 53, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0011", "source_id": "SOURCE-20260217-016", "category": "concept", "content": "The purpose of a harness engineer is to prepare and deliver context to agents so they can autonomously complete work.", "line_start": 54, "line_end": 54, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0012", "source_id": "SOURCE-20260217-016", "category": "claim", "content": "Agents can become myopic and enter 'doom loops' where they make small variations to the same broken approach repeatedly.", "line_start": 57, "line_end": 58, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.2, 0.4, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0013", "source_id": "SOURCE-20260217-016", "category": "praxis_hook", "content": "Implement a LoopDetectionMiddleware that tracks per-file edit counts via tool call hooks and adds context like 'â€¦consider reconsidering your approach' after N edits to the same file to help agents recover from 'doom loops'.", "line_start": 59, "line_end": 61, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.4, 0.1, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0014", "source_id": "SOURCE-20260217-016", "category": "claim", "content": "Guardrails and design heuristics, like LoopDetectionMiddleware, are currently necessary to help agents execute correctly and autonomously due to perceived model issues, but may become unnecessary as models improve.", "line_start": 63, "line_end": 65, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.4, 0.6, 0.1, 0.2, 0.5, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0015", "source_id": "SOURCE-20260217-016", "category": "claim", "content": "Optimizing reasoning compute spend is beneficial for most subtasks, even though the maximum reasoning budget can be used for every task.", "line_start": 68, "line_end": 69, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.2, 0.5, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0016", "source_id": "SOURCE-20260217-016", "category": "claim", "content": "More reasoning helps agents evaluate each step, but can burn over 2x more tokens/time, creating a tradeoff with terminal bench timeout limits.", "line_start": 71, "line_end": 71, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.2, 0.5, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0017", "source_id": "SOURCE-20260217-016", "category": "claim", "content": "Reasoning is beneficial for planning to fully understand difficult problems and for later-stage verification to catch mistakes and submit solutions.", "line_start": 73, "line_end": 75, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.2, 0.5, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0018", "source_id": "SOURCE-20260217-016", "category": "framework", "content": "A 'reasoning sandwich' heuristic for compute allocation involves using xhigh reasoning for planning and understanding (first 25% of budget), high reasoning for building and iterating (middle 50%), and xhigh reasoning for final verification (last 25%).", "line_start": 76, "line_end": 77, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260217-016-0019", "source_id": "SOURCE-20260217-016", "category": "claim", "content": "Running agents only at xhigh reasoning scored poorly (53.9%) due to timeouts compared to 63.6% at high reasoning, while a 'reasoning sandwich' approach achieved 66.5%.", "line_start": 80, "line_end": 81, "chaperone": {"context_type": "anecdote", "argument_role": "evidence", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.3, 0.7], "opposes_atom_ids": []}, "extensions": {}}
