{"atom_id": "ATOM-SOURCE-20260211-009-0001", "source_id": "SOURCE-20260211-009", "category": "claim", "content": "OpenAI's engineering team built a real product where every line of code was written by Codex over five months.", "line_start": 6, "line_end": 8, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.1, 0.8, 0.1, 0.2, 0.3, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0002", "source_id": "SOURCE-20260211-009", "category": "claim", "content": "StrongDM developed a \"Software Factory\" system where agents write and review all code without human intervention.", "line_start": 8, "line_end": 10, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.1, 0.8, 0.1, 0.2, 0.3, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0003", "source_id": "SOURCE-20260211-009", "category": "claim", "content": "The author has been using a similar agent-driven software development process at their company since November 2025.", "line_start": 12, "line_end": 12, "chaperone": {"context_type": "anecdote", "argument_role": "evidence", "tension_vector": [0.1, 0.7, 0.1, 0.2, 0.3, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0004", "source_id": "SOURCE-20260211-009", "category": "claim", "content": "OpenAI's project, started in August 2025, resulted in approximately 1 million lines of code and 1,500 merged pull requests in five months, with an estimated 10x faster development than manual coding.", "line_start": 22, "line_end": 26, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.1, 0.8, 0.1, 0.2, 0.3, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0005", "source_id": "SOURCE-20260211-009", "category": "concept", "content": "A core philosophy of OpenAI's agent-driven development was that humans never contributed code directly, making it a constraint and a guiding principle.", "line_start": 28, "line_end": 29, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.2, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0006", "source_id": "SOURCE-20260211-009", "category": "claim", "content": "OpenAI's engineering team's primary job shifted to enabling agents to do useful work, focusing on building feedback loops, structuring documentation, and designing environments rather than writing code.", "line_start": 33, "line_end": 38, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.7, 0.1, 0.3, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0007", "source_id": "SOURCE-20260211-009", "category": "claim", "content": "OpenAI reports single Codex runs working on one task for six hours straight, often while the team sleeps.", "line_start": 40, "line_end": 40, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.2, 0.7, 0.1, 0.2, 0.3, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0008", "source_id": "SOURCE-20260211-009", "category": "concept", "content": "StrongDM's approach treats generated code like model weights, meaning it is considered opaque and validated through external behavior rather than by reading it for correctness.", "line_start": 50, "line_end": 53, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.5, 0.1, 0.3, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0009", "source_id": "SOURCE-20260211-009", "category": "framework", "content": "StrongDM built \"Digital Twin Universes\"—behavioral clones of services like Okta, Jira, Slack, and Google Docs—to rigorously validate agent-generated code by allowing thousands of integration scenarios per hour without real-world API constraints.", "line_start": 55, "line_end": 59, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.8, 0.6, 0.1, 0.3, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0010", "source_id": "SOURCE-20260211-009", "category": "praxis_hook", "content": "To prevent agents from gaming tests, StrongDM stores test scenarios as a holdout set outside the codebase, ensuring they cannot be rewritten to match broken code.", "line_start": 61, "line_end": 63, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.6, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0011", "source_id": "SOURCE-20260211-009", "category": "claim", "content": "StrongDM's coding agent, Attractor, is defined by three markdown files containing natural language specifications, which can be fed to any modern coding agent to build itself.", "line_start": 65, "line_end": 67, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.5, 0.6, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0012", "source_id": "SOURCE-20260211-009", "category": "praxis_hook", "content": "Both OpenAI and StrongDM found that using \"boring\" (composable, stable, well-documented) technology is advantageous for coding agents because it is well-represented in training data and has stable APIs.", "line_start": 75, "line_end": 79, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.7, 0.1, 0.2, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0013", "source_id": "SOURCE-20260211-009", "category": "praxis_hook", "content": "For agent-driven development, all knowledge must reside within the repository (e.g., structured documentation, natural language specs in markdown) because agents cannot access information outside of it.", "line_start": 81, "line_end": 85, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.7, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0014", "source_id": "SOURCE-20260211-009", "category": "praxis_hook", "content": "Agents require full, bootable environments per branch to run and validate their built code before human review, including capabilities like driving UI and taking screenshots.", "line_start": 87, "line_end": 91, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.8, 0.7, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0015", "source_id": "SOURCE-20260211-009", "category": "praxis_hook", "content": "Mandatory automated verification, such as through DevTools Protocol, observability tooling, or external holdout scenarios, is crucial because neither team trusts the agent's self-reported confidence.", "line_start": 93, "line_end": 96, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.8, 0.7, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0016", "source_id": "SOURCE-20260211-009", "category": "praxis_hook", "content": "Agent-to-agent code review loops are implemented, with OpenAI pushing most review to agents and StrongDM removing human review entirely.", "line_start": 98, "line_end": 100, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.6, 0.1, 0.3, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0017", "source_id": "SOURCE-20260211-009", "category": "praxis_hook", "content": "To manage \"AI slop\" (agent-generated drift), recurring agents are used to scan for pattern violations and open small refactoring pull requests, acting as continuous garbage collection.", "line_start": 102, "line_end": 105, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.6, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0018", "source_id": "SOURCE-20260211-009", "category": "claim", "content": "The new generation of models, specifically GPT 5.2 Codex Extra High, unlocked the ability for agents to do complex, sustained work over long periods without context rot, making self-driving software viable.", "line_start": 110, "line_end": 114, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.6, 0.7, 0.1, 0.3, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0019", "source_id": "SOURCE-20260211-009", "category": "claim", "content": "A single agent can now take a bug report, reproduce the failure, record a video, implement a fix, validate it by driving the application, open a pull request, respond to review feedback, handle CI failures, and merge, often in single runs lasting six hours.", "line_start": 118, "line_end": 126, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.5, 0.7, 0.1, 0.3, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0020", "source_id": "SOURCE-20260211-009", "category": "praxis_hook", "content": "When implementing software, Codex can handle the entire process, including writing code, tests, updating configuration, and managing dependencies, without human intervention.", "line_start": 121, "line_end": 124, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0021", "source_id": "SOURCE-20260211-009", "category": "praxis_hook", "content": "For UI review, a two-model approach using Opus to review Playwright screenshots after Codex's initial implementation can catch visual issues that Codex misses, leading to better results than either model alone.", "line_start": 126, "line_end": 129, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.8, 0.3, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0022", "source_id": "SOURCE-20260211-009", "category": "praxis_hook", "content": "The author's current software development workflow involves Claude Opus 4.6 writing the initial plan for features, focusing on intent and edge cases, which is then augmented by GPT 5.3 Codex for technical detail and gap filling.", "line_start": 130, "line_end": 136, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.8, 0.6, 0.1, 0.3, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0023", "source_id": "SOURCE-20260211-009", "category": "praxis_hook", "content": "For code review, multiple GitHub action-supported agents, each running a different model, can review pull requests, routing findings back to Codex for fixes until all agent reviewers pass.", "line_start": 132, "line_end": 135, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0024", "source_id": "SOURCE-20260211-009", "category": "praxis_hook", "content": "High-stakes code changes still require human review of the pull request and preview deployment, as the judgment to identify such changes has not yet been automated.", "line_start": 137, "line_end": 140, "chaperone": {"context_type": "method", "argument_role": "limitation", "tension_vector": [0.2, 0.8, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0025", "source_id": "SOURCE-20260211-009", "category": "praxis_hook", "content": "To ensure robust testing, every branch should receive a full preview deployment across the entire monorepo, using scenario-based seed data for reproducibility and mandatory E2E tests via Playwright that must pass before merging.", "line_start": 142, "line_end": 148, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.4, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0026", "source_id": "SOURCE-20260211-009", "category": "claim", "content": "For agents to reason effectively, all relevant systems like feature flags, local development, staging, production, and logs must be accessible to them.", "line_start": 150, "line_end": 152, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.5, 0.7, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0027", "source_id": "SOURCE-20260211-009", "category": "claim", "content": "The author operates as a one-person engineering team.", "line_start": 157, "line_end": 157, "chaperone": {"context_type": "anecdote", "argument_role": "claim", "tension_vector": [0.3, 0.2, 0.1, 0.1, 0.2, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0028", "source_id": "SOURCE-20260211-009", "category": "concept", "content": "The role of a 'software engineer' has evolved to encompass engineer, product manager, and agent orchestrator, requiring skills in system design, translating product intent into specs, and building scaffolding for agent productivity.", "line_start": 159, "line_end": 162, "chaperone": {"context_type": "hypothesis", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.3, 0.6, 0.5], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260211-009-0029", "source_id": "SOURCE-20260211-009", "category": "concept", "content": "The job title 'Senior Agent Native Product Engineer' describes a role focused on designing systems and environments for agents to write software, rather than writing the software directly.", "line_start": 164, "line_end": 164, "chaperone": {"context_type": "hypothesis", "argument_role": "claim", "tension_vector": [0.8, 0.2, 0.1, 0.4, 0.5, 0.4], "opposes_atom_ids": []}, "extensions": {}}
