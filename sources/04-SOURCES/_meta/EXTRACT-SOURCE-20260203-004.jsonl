{"atom_id": "ATOM-SOURCE-20260203-004-0001", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "The OpenClaw platform is an autonomous agent runtime environment that shifts from ephemeral, cloud-hosted chat interfaces to a persistent, local-first, event-driven architecture.", "line_start": 4, "line_end": 7, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.3, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0002", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "OpenClaw operates as a continuous daemon, called the Gateway, which maintains a persistent event loop, unlike traditional Request-Response models where an agent is dormant until queried.", "line_start": 7, "line_end": 10, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.4, 0.1, 0.2, 0.4, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0003", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "OpenClaw's architecture supports long-running, multi-turn workflows, autonomous background processing, and complex multi-agent topologies on a single host.", "line_start": 10, "line_end": 12, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.4, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0004", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "The Gateway is an always-on process at the core of the OpenClaw system, functioning as its central nervous system, responsible for protocol multiplexing, session state management, token accounting, and agent loop orchestration.", "line_start": 14, "line_end": 17, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0005", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "The Gateway binds to a local control plane (defaulting to WebSocket on 127.0.0.1:18789) and provides a unified API for local UIs and remote control interfaces.", "line_start": 17, "line_end": 20, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0006", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "OpenClaw's design decouples the agent's cognitive runtime (LLM inference) from the I/O layer, allowing it to persist across UI restarts and handle asynchronous events like cron jobs or webhooks.", "line_start": 20, "line_end": 24, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.4, 0.1, 0.2, 0.4, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0007", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "Agents in OpenClaw are logical units of cognition, each with a distinct identity, workspace, session store, and configuration profile, architecturally isolated with their own memory banks and permission scopes.", "line_start": 26, "line_end": 29, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.4, 0.1, 0.2, 0.4, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0008", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "Nodes in OpenClaw are paired devices (iOS/Android endpoints, secondary desktop clients) that form a distributed hardware mesh, extending the agent's sensory and actuation range by exposing their hardware capabilities to the Gateway.", "line_start": 29, "line_end": 33, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.4, 0.1, 0.2, 0.4, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0009", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "OpenClaw's interaction model is fundamentally Event-Driven, where the Gateway normalizes signals from various sources (messages, temporal events, hardware interrupts) into a standard event format and routes them deterministically to the appropriate Agent Runtime.", "line_start": 35, "line_end": 39, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.4, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0010", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "The routing logic in OpenClaw is crucial for its multi-agent capabilities, enabling a single inbound communication channel (e.g., a WhatsApp phone number) to serve multiple distinct agent personalities based on the sender's identity.", "line_start": 39, "line_end": 43, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.4, 0.1, 0.2, 0.4, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0011", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "OpenClaw replaces unstructured shell-script 'skills' with typed, first-class tools that offer structured inputs, outputs, and validation, enhancing reliability and security by allowing the Gateway to enforce strict schema validation.", "line_start": 47, "line_end": 51, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.2, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0012", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "The `exec` tool is the foundational primitive for system interaction in OpenClaw, allowing agents to execute shell commands within configured environments (host OS or Dockerized sandbox).", "line_start": 56, "line_end": 58, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0013", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "The `exec` tool supports both synchronous execution for immediate feedback and asynchronous execution for long-running tasks.", "line_start": 60, "line_end": 60, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0014", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "Access to the `exec` tool is heavily gated by the tool restriction chain due to its security implications as the primary vector for system modification.", "line_start": 61, "line_end": 62, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0015", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "The `elevated` parameter in the `exec` tool allows an agent to request host-level access, bypassing sandbox constraints, if global and agent-specific policies permit.", "line_start": 62, "line_end": 64, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0016", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "The `process` tool in OpenClaw manages the lifecycle of commands initiated by the `exec` tool, allowing agents to monitor complex builds or servers asynchronously.", "line_start": 75, "line_end": 77, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0017", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "The `process` tool maintains a registry of backgrounded processes and allows agents to attach to them to read logs, send input to stdin, or terminate them.", "line_start": 79, "line_end": 81, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0018", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "The browser tool integrates with the agent's multimodal capabilities, allowing it to generate \"AI snapshots\" (semantic DOM representations optimized for LLM reading) or \"Aria snapshots\" (accessibility tree dumps).", "line_start": 80, "line_end": 82, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0019", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "The `log` action of the `process` tool supports pagination via offset and limit to prevent context window overflow when reading large build logs.", "line_start": 82, "line_end": 83, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0020", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "The browser tool's action set includes: navigate, click, type, press (keys), hover, drag, fill (forms), screenshot, pdf, upload, and dialog (handle alerts).", "line_start": 83, "line_end": 84, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0021", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "The message tool is a unified abstraction layer for all supported chat protocols (Discord, Slack, WhatsApp, Telegram, Signal, iMessage, MS Teams), allowing the agent to use the same 'send' action regardless of the underlying transport, with the Gateway handling protocol-specific translation.", "line_start": 88, "line_end": 92, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0022", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "The Gateway enforces strict session binding for message tool calls, constraining them to the target of the active session to prevent accidental or malicious broadcasting of private responses to different channels or users.", "line_start": 100, "line_end": 102, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0023", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "Agentic Concurrency is achieved through the `sessions_spawn` tool, which allows an agent to fork execution by spawning a sub-agent to perform a specific task in isolation.", "line_start": 108, "line_end": 109, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0024", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "The `sessions_spawn` tool takes parameters such as `task` (natural language instruction for the sub-agent), `label` (human-readable tag), `agentId` (target specific agent configuration), `model` (override default model), `runTimeoutSeconds` (hard timeout), and `cleanup` ('keep' or 'delete').", "line_start": 111, "line_end": 119, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0025", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "When `sessions_spawn` is used, it immediately returns a `runId` and `childSessionKey`, and the sub-agent executes asynchronously, with its result injected back into the parent session via an \"Announce\" step upon completion.", "line_start": 121, "line_end": 122, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0026", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "`sessions_send` enables inter-session communication and supports a `timeoutSeconds` parameter: if greater than 0, it acts as a synchronous RPC call waiting for a reply; if 0, it behaves as a fire-and-forget message.", "line_start": 125, "line_end": 126, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0027", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "`sessions_list` allows agents to discover active contexts, which can be filtered by kind (main, group, cron) or recency.", "line_start": 127, "line_end": 127, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0028", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "The `cron` tool manages the scheduler, allowing agents to self-schedule tasks using `add`, `update`, or `remove` actions, requiring a full job schema.", "line_start": 130, "line_end": 131, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0029", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "The `gateway` tool provides administrative control, including `config.get`, `config.patch` for hot updates, and `restart`, which reboots the Gateway process and requires explicit enablement in `openclaw.json` (`commands.restart: true`) to prevent accidental shutdowns.", "line_start": 132, "line_end": 135, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0030", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "In OpenClaw, a Session is the fundamental unit of state, representing a continuous thread of conversation and context, and is file-system backed rather than stored as database rows.", "line_start": 140, "line_end": 141, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0031", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "Session data in OpenClaw is strictly isolated per agent to prevent context contamination, stored at `~/.openclaw/agents/<agentId>/sessions/`.", "line_start": 145, "line_end": 146, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0032", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "OpenClaw uses a deterministic key generation strategy to map external inputs to internal sessions, including formats for Single-Agent Mode (`agent:main:<mainKey>`), Multi-Agent Mode (`agent:<agentId>:<mainKey>`), Group Chats (`agent:<agentId>:<channel>:group:<id>`), and Sub-Agents (`agent:<agentId>:subagent:<uuid>`).", "line_start": 153, "line_end": 159, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.2, 0.2, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0033", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "The `sessions_spawn` tool in OpenClaw instantiates a full Agent Runtime context, not merely calling another model, when invoked.", "line_start": 162, "line_end": 162, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0034", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "When `sessions_spawn` is invoked, it involves forking (generating a unique session key for the sub-agent), context construction (creating a fresh context window), and isolation (sub-agent runs with its own tool permissions, by default unable to spawn further sub-agents).", "line_start": 164, "line_end": 168, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.2, 0.2, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0035", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "A critical flaw in earlier versions of OpenClaw, known as the \"Herbert Yang\" issue, involved `agentId` and `model` overrides in `sessions_spawn` failing to propagate routing context correctly, leading to \"malformed tool calls\" or 400 errors from providers like OpenRouter.", "line_start": 169, "line_end": 172, "chaperone": {"context_type": "anecdote", "argument_role": "evidence", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.3, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0036", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "OpenClaw's Cron system provides temporal drive, transforming it from a reactive bot into a proactive agent.", "line_start": 169, "line_end": 169, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0037", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "Release 2026.2.2 of OpenClaw, attributed to @justinhuangcode, fixed the \"Herbert Yang\" issue by ensuring that `accountId` and binding contexts are correctly inherited by the embedded run, allowing sub-agents to utilize the correct provider credentials and routing identities.", "line_start": 172, "line_end": 175, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0038", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "A cron job in OpenClaw is defined by a structured object with fields for `name` (human-readable identifier), `schedule` (timing definition), `payload` (execution logic and target), and `sessionTarget` (execution context: main or isolated).", "line_start": 173, "line_end": 179, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0039", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "OpenClaw implements aggressive hygiene protocols to manage the finite context window of LLMs.", "line_start": 178, "line_end": 178, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0040", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "OpenClaw's session expiration includes a daily reset (sessions roll over at 04:00 AM local time, archiving the previous day's chat) and an idle reset (a new session starts if inactive for a configurable `idleMinutes` duration).", "line_start": 180, "line_end": 183, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.2, 0.2, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0041", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "OpenClaw's cron schedule object supports three modes: `at` for one-shot execution at a specific UTC ISO timestamp (with optional delete-after-run), `every` for recurring intervals (e.g., \"30m\", \"1h\"), and `cron` for standard 5-field Unix cron syntax.", "line_start": 183, "line_end": 188, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0042", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "OpenClaw's pruning strategy, executed before every LLM call if `mode: \"cache-ttl\"` is active, removes verbose `toolResult` messages older than a defined `ttl` (default: 5 minutes), while user and assistant messages are never pruned, and the last `keepLastAssistants` (default: 3) tool results are preserved.", "line_start": 184, "line_end": 189, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.2, 0.2, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0043", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "Compaction, distinct from pruning, summarizes older segments of conversation history into persistent memory notes, freeing up tokens in the sliding window without losing semantic content.", "line_start": 190, "line_end": 190, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0044", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "The `sessionTarget` field in an OpenClaw cron job determines the execution context, fundamentally changing how the job executes, either in the `main` session loop or an `isolated` dedicated session.", "line_start": 192, "line_end": 192, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0045", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "To execute an OpenClaw cron job within the primary session loop, set `sessionTarget: main` and use a `systemEvent` payload; this is suitable for tasks requiring awareness of recent user interactions like reminders or daily briefings, and triggers a heartbeat wakeup of the main agent.", "line_start": 195, "line_end": 201, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0046", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "To execute an OpenClaw cron job in a dedicated, fresh session with zero context, set `sessionTarget: isolated` and use an `agentTurn` payload; this is ideal for heavy background processing, log scrubbing, or fetching external data without polluting the main context window, and the Gateway proactively spawns the new session immediately.", "line_start": 202, "line_end": 210, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0047", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "OpenClaw adheres to the AgentSkills specification, a standardized format for portable agent capabilities that allows skills to be shared, versioned, and gated.", "line_start": 215, "line_end": 215, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0048", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "An OpenClaw Skill is defined by a directory containing a SKILL.md file, which combines YAML Frontmatter metadata (e.g., name, description, user-invocable, disable-model-invocation, command-dispatch, command-tool, and OpenClaw-specific metadata like OS gating, binary dependencies, environment variables, and config keys) with a Markdown instruction body for prompt injection.", "line_start": 219, "line_end": 239, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0049", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "OpenClaw resolves multiple skills with a strict hierarchy from highest to lowest priority: Workspace Skills (per-agent, user-owned), Managed Skills (local overrides shared across agents), and Bundled Skills (shipped with OpenClaw distribution).", "line_start": 243, "line_end": 248, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0050", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "The `{baseDir}` variable in OpenClaw skills resolves dynamically based on the skill's location, pointing to the agent's workspace for workspace skills or the global skills directory for shared skills, allowing reliable referencing of local assets or scripts.", "line_start": 250, "line_end": 252, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0051", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "Standalone Skills in OpenClaw are purely declarative (Markdown) and can only instruct the agent on how to use existing tools, without introducing new TypeScript/Node.js runtime logic.", "line_start": 256, "line_end": 257, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0052", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "Plugins in OpenClaw are integrated modules that can register new Tools via a `register` function and facilitate Skills via `openclaw.plugin.json`, required for adding new fundamental capabilities like binary-level interfaces to hardware devices.", "line_start": 258, "line_end": 261, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0053", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "OpenClaw's configuration file (`openclaw.json`) supports complex multi-agent setups through the `agents.list` array.", "line_start": 265, "line_end": 265, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0054", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "OpenClaw's Gateway uses a deterministic \"Most Specific Match Wins\" Binding Resolution Order to route inbound messages to the correct agent, prioritizing Peer Match (exact User ID), then Guild/Team Match, Account Match (specific Channel Account), Channel Match (generic wildcard), and finally a Fallback to the default or first agent.", "line_start": 283, "line_end": 290, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0055", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "To implement a \"Shared Account\" pattern in OpenClaw, where a single channel account serves multiple users, configure peer-specific bindings (e.g., `peer: \"+1234...\"` to Agent A and `peer: \"+5678...\"` to Agent B) so the Gateway routes messages to isolated agent instances, ensuring data privacy and context isolation.", "line_start": 293, "line_end": 298, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0056", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "To enable direct agent-to-agent communication in OpenClaw, which is disabled by default to prevent loops, configure the `agentToAgent` tool in the allowlist; agents can then use the `message` tool or `sessions_send` to address each other as chat peers.", "line_start": 302, "line_end": 305, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0057", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "OpenClaw implements a defense-in-depth security model, which is critical for a system that allows LLMs to execute shell commands.", "line_start": 309, "line_end": 309, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0058", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "To enable direct agent-to-agent communication in OpenClaw, configure the `agentToAgent` tool in the allowlist, then agents can use the `message` tool or `sessions_send` to communicate.", "line_start": 310, "line_end": 314, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.1, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0059", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "OpenClaw calculates tool permissions through an 8-layer hierarchy, applying a strict \"Deny Wins\" logic where if any layer denies a tool, it is blocked regardless of other allowances, starting with the Global Tool Profile (`tools.profile`).", "line_start": 313, "line_end": 318, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0060", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "OpenClaw employs a defense-in-depth security model, which is crucial for a system that permits LLMs to execute shell commands.", "line_start": 319, "line_end": 320, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.2, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0061", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "OpenClaw's security architecture uses an 8-layer Tool Restriction Chain where permissions are calculated by filtering requested tool usage, and the 'Deny Wins' logic means any layer denying a tool blocks it.", "line_start": 323, "line_end": 326, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.5, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0062", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "The 8 layers of OpenClaw's Tool Restriction Chain are: Global Tool Profile, Global Provider Profile, Global Policy, Provider Policy, Agent Policy (primary user config), Agent Provider Policy, Sandbox Policy, and Sub-agent Policy.", "line_start": 328, "line_end": 339, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.5, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0063", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "OpenClaw's sandboxing strategy is built on Docker and offers three modes: 'off' (tools run on host, high risk/power), 'non-main' (only main session on host, groups/cron in sandbox), and 'all' (everything runs in sandbox).", "line_start": 342, "line_end": 348, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.5, 0.1, 0.1, 0.6, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0064", "source_id": "SOURCE-20260203-004", "category": "claim", "content": "OpenClaw's sandboxing strategy offers three scopes: 'session' (fresh container per session, most secure but slower), 'agent' (persistent container per agent), and 'shared' (single container shared by multiple agents).", "line_start": 349, "line_end": 352, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.5, 0.1, 0.1, 0.6, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0065", "source_id": "SOURCE-20260203-004", "category": "framework", "content": "The Syncrescendence constellation architecture (CAPTURE → DISPATCH → RETURN) maps to OpenClaw primitives: CAPTURE uses Gateway Event Loop, DISPATCH uses sessions_spawn/Routing, and RETURN uses the Announce Step.", "line_start": 357, "line_end": 373, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.4, 0.1, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0066", "source_id": "SOURCE-20260203-004", "category": "concept", "content": "Syncrescendence's memory system is repo-based, relying on a Git repository as the authoritative ground truth, while OpenClaw uses a hybrid approach with durable MEMORY.md, ephemeral daily logs (memory/YYYY-MM-DD.md), and a hybrid SQLite Vector Search + FTS5 index for search.", "line_start": 376, "line_end": 382, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.5, 0.1, 0.1, 0.3, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0067", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "To integrate Syncrescendence's repo-truth with OpenClaw, bypass OpenClaw's vector store for authoritative data by configuring a skill that instructs the agent to use `exec` to directly grep or read the Syncrescendence repository.", "line_start": 383, "line_end": 386, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.4, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0068", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "OpenClaw can orchestrate external CLIs like Gemini or Claude Code by defining a Skill that uses the `exec` tool to run commands (e.g., `exec(command='gemini query \"...\"')`).", "line_start": 389, "line_end": 392, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.4, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260203-004-0069", "source_id": "SOURCE-20260203-004", "category": "praxis_hook", "content": "To automate external CLI invocation in OpenClaw, use a cron job with `sessionTarget: \"isolated\"` to run a script that invokes CLIs, processes output, and reports back using the `message` tool (via curl webhook or `sessions_send`).", "line_start": 393, "line_end": 394, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.4, 0.1, 0.1, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
