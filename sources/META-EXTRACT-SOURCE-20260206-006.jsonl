{"atom_id": "ATOM-SOURCE-20260206-006-0001", "source_id": "SOURCE-20260206-006", "category": "praxis_hook", "content": "To ensure agents complete tasks effectively, implement 'Verify + Learn Loops' where agents must verify task completion and extract lessons to prevent recurring mistakes.", "line_start": 19, "line_end": 21, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0002", "source_id": "SOURCE-20260206-006", "category": "framework", "content": "The 'Verify + Learn Loop' consists of the following steps: ANALYZE → RECOMMEND → [APPROVE] → EXECUTE → VERIFY → LEARN. If verification fails, the agent retries and extracts a lesson.", "line_start": 22, "line_end": 26, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0003", "source_id": "SOURCE-20260206-006", "category": "praxis_hook", "content": "Design agent outputs with a 'Decision Interface Pattern' that forces a clear choice (e.g., 'Approve X or Reject X') to capture feedback and improve future performance.", "line_start": 33, "line_end": 35, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0004", "source_id": "SOURCE-20260206-006", "category": "framework", "content": "A Decision Interface Pattern for agent output includes: ACTION (specific title), Data (numbers driving it), Impact (expected outcome), Effort (Low/Med/High), and a clear prompt for approval or rejection with a reason.", "line_start": 37, "line_end": 43, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0005", "source_id": "SOURCE-20260206-006", "category": "praxis_hook", "content": "Implement a codified system of 'Autonomy Levels' for agents, starting them with restricted permissions (e.g., insights only) and gradually unlocking more execution capabilities as they prove reliable.", "line_start": 50, "line_end": 52, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0006", "source_id": "SOURCE-20260206-006", "category": "framework", "content": "Agent Autonomy Levels: Level 1 (Report only), Level 2 (Recommend + execute on approval), Level 3 (Execute low-risk, report after), Level 4 (Full autonomy with weekly summary). New agents begin at Level 1.", "line_start": 54, "line_end": 60, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0007", "source_id": "SOURCE-20260206-006", "category": "praxis_hook", "content": "Organize agent workspaces using a simple file-based architecture (e.g., text files for identity, memory, learnings) rather than complex databases, to facilitate easy debugging and human readability.", "line_start": 65, "line_end": 68, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0008", "source_id": "SOURCE-20260206-006", "category": "framework", "content": "A file-based agent workspace architecture includes: SOUL.md (identity), AGENTS.md (operating manual), MEMORY.md (long-term learnings), shared-learnings/ (cross-agent knowledge), feedback/ (decision logs), and docs/ (playbooks).", "line_start": 69, "line_end": 78, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0009", "source_id": "SOURCE-20260206-006", "category": "praxis_hook", "content": "Implement Cron Scheduling for agents to proactively push updates and surface problems on a defined schedule (e.g., daily SEO digest, deal recommendations), rather than waiting for user queries.", "line_start": 83, "line_end": 85, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0010", "source_id": "SOURCE-20260206-006", "category": "praxis_hook", "content": "For security, store credentials in a password manager (e.g., 1Password), restrict bot access to allowlisted users, log every decision for audit, and run agents locally to keep data off random clouds.", "line_start": 94, "line_end": 97, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0011", "source_id": "SOURCE-20260206-006", "category": "framework", "content": "A multi-agent coordination architecture can involve an orchestrator agent (e.g., Alfred) delegating tasks to specialist agents (e.g., Oracle for SEO, Flash for content, Arrow for sales) who share a common 'learnings' folder.", "line_start": 110, "line_end": 112, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0012", "source_id": "SOURCE-20260206-006", "category": "praxis_hook", "content": "Use less expensive AI models (e.g., Sonnet) for routine, daily tasks and reserve more powerful, costly models (e.g., Opus) for high-stakes decisions to optimize cost efficiency.", "line_start": 117, "line_end": 119, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0013", "source_id": "SOURCE-20260206-006", "category": "praxis_hook", "content": "Run each scheduled agent job in its own isolated session to prevent context bleed, ensuring a clean slate for each task, which results in smaller context windows, faster processing, and lower costs.", "line_start": 123, "line_end": 125, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0014", "source_id": "SOURCE-20260206-006", "category": "praxis_hook", "content": "To manage context overload and improve efficiency, frequently 'compact' agent context and, for complex tasks, spawn subagents to work in parallel.", "line_start": 129, "line_end": 132, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0015", "source_id": "SOURCE-20260206-006", "category": "praxis_hook", "content": "Plan and test agent workflows using a dedicated coding environment (e.g., Claude Code) before deploying them to the operational system (e.g., OpenClaw) to allow for deeper, more thoughtful planning.", "line_start": 136, "line_end": 138, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260206-006-0016", "source_id": "SOURCE-20260206-006", "category": "praxis_hook", "content": "Store agent 'learnings' and preferences in external files (e.g., shared-learnings/oracle/preferences.md) that agents read on demand, rather than embedding them in every prompt, to scale knowledge without prompt bloat.", "line_start": 145, "line_end": 145, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
