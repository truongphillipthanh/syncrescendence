{"atom_id": "ATOM-SOURCE-20260207-016-0001", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To build an AI agent system, you don't need to know how to code; you just need to know how to interact with an AI coding assistant.", "line_start": 9, "line_end": 10, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0002", "source_id": "SOURCE-20260207-016", "category": "claim", "content": "A functional AI agent system can be built using Next.js, Supabase, and a Virtual Private Server (VPS), with a monthly cost of $8 fixed plus LLM usage.", "line_start": 24, "line_end": 24, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0003", "source_id": "SOURCE-20260207-016", "category": "claim", "content": "An AI agent system can be implemented without relying on OpenAI Assistants API, LangChain, or AutoGPT, instead using PostgreSQL, Node.js workers, and a rule engine.", "line_start": 26, "line_end": 27, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0004", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To start an AI agent system, begin with three agents: a coordinator, an executor, and an observer, to establish a fully working loop.", "line_start": 29, "line_end": 29, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0005", "source_id": "SOURCE-20260207-016", "category": "framework", "content": "The core data model for an AI agent system consists of four tables forming a closed loop: `ops_mission_proposals` (agent ideas), `ops_missions` (approved tasks), `ops_mission_steps` (concrete execution steps), and `ops_agent_events` (event stream triggering new ideas).", "line_start": 37, "line_end": 41, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0006", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To create database tables for an AI agent system, provide table definitions to an AI coding assistant and ask it to generate Supabase SQL migrations.", "line_start": 53, "line_end": 53, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0007", "source_id": "SOURCE-20260207-016", "category": "concept", "content": "A 'Proposal' in an AI agent system is an agent's request, such as a social media agent wanting to post a tweet, which the system then reviews for approval or rejection.", "line_start": 56, "line_end": 58, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.2, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0008", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Implement a single proposal intake pipeline as the sole entry point for all proposals in an AI agent system, regardless of their origin (agent initiative, automatic trigger, or another agent's reaction), to ensure consistent approval processes.", "line_start": 62, "line_end": 64, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0009", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Before inserting a proposal, check 'Cap Gates' (e.g., daily limits, quotas) and reject the proposal immediately if limits are met, preventing tasks from piling up in the queue.", "line_start": 68, "line_end": 70, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0010", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Log rejected proposals for audit trails instead of silently dropping them.", "line_start": 96, "line_end": 96, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0011", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Store quotas and feature flags in an `ops_policy` table with a key-value (JSONB) structure, rather than hardcoding them, to allow for dynamic adjustments without redeployment.", "line_start": 99, "line_end": 100, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0012", "source_id": "SOURCE-20260207-016", "category": "concept", "content": "A 'Heartbeat' in an AI agent system is a periodic function (e.g., every 5 minutes) that checks and processes critical system components like triggers, reaction queues, insights, outcomes, and recovers stuck tasks or conversations.", "line_start": 120, "line_end": 122, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.2, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0013", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To schedule tasks on a Linux system, use crontab. The `*/5 * * * *` syntax means the command will run every 5 minutes. For Vercel deployments, use its built-in cron functionality instead of crontab.", "line_start": 142, "line_end": 149, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.9, 0.0, 0.6, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0014", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Implement a system heartbeat where each step is wrapped in a try-catch block to prevent one failing component from taking down the entire system.", "line_start": 149, "line_end": 149, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0015", "source_id": "SOURCE-20260207-016", "category": "framework", "content": "Trigger rules define conditions under which an agent proposal is created, specifying the trigger event, conditions, target agent, and cooldown period. They come in two flavors: reactive triggers (responding to past events like `tweet_high_engagement` or `mission_failed`) and proactive triggers (agents initiating work on a schedule, like `proactive_scan_signals` or `proactive_draft_tweet`).", "line_start": 153, "line_end": 189, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.0, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0016", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Proactive triggers can incorporate randomness to simulate natural behavior, including a skip probability (e.g., 10-15% chance of not firing), topic rotation, and jitter (e.g., 25-45 minute random delay) to prevent simultaneous firing.", "line_start": 210, "line_end": 213, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.0, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0017", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "When evaluating triggers, prioritize checking cooldowns (cheap) before calling potentially expensive checker functions. Implement a budget (e.g., 4 seconds) for the evaluator; if the budget is exceeded, remaining rules should wait for the next heartbeat to prevent serverless function timeouts.", "line_start": 215, "line_end": 220, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.0, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0018", "source_id": "SOURCE-20260207-016", "category": "framework", "content": "The reaction matrix defines how agents respond to each other's actions. It's a JSON policy specifying patterns with `source` agent, event `tags`, `target` agent, reaction `type`, `probability` of reaction, and a `cooldown` period.", "line_start": 224, "line_end": 254, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.0, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0019", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To manage agent-to-agent reactions: 1) Log agent actions as events with tags. 2) Use an event hook to check the reaction matrix for matching patterns. 3) If a pattern matches and passes probability/cooldown checks, add the reaction to a queue. 4) Process the reaction queue during the next heartbeat to create proposals, ensuring reactions go through standard safety gates like quota checks.", "line_start": 256, "line_end": 264, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.0, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0020", "source_id": "SOURCE-20260207-016", "category": "claim", "content": "Using a queue for agent reactions, rather than immediate execution, allows reactions to pass through the same proposal gates (quota checks, auto-approve, cap gates) as other tasks, and facilitates inspection and debugging.", "line_start": 266, "line_end": 269, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.0, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0021", "source_id": "SOURCE-20260207-016", "category": "framework", "content": "A multi-agent system can be structured into three layers: a VPS (agents' brain + hands for thinking and executing tasks), Vercel (agents' process manager for approving proposals, evaluating triggers, and health monitoring), and Supabase (agents' shared memory, serving as the single source of truth for all state and data).", "line_start": 273, "line_end": 278, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.0, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0022", "source_id": "SOURCE-20260207-016", "category": "analogy", "content": "In a multi-agent system, the VPS is like an employee doing the work, Vercel is like the boss issuing directives, and Supabase is like the company's shared documentation that everyone reads from and writes to.", "line_start": 280, "line_end": 282, "chaperone": {"context_type": "consensus", "argument_role": "evidence", "tension_vector": [0.1, 0.8, 0.0, 0.0, 0.6, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0023", "source_id": "SOURCE-20260207-016", "category": "claim", "content": "Conversations are crucial for emergent intelligence in multi-agent systems, facilitating information synchronization, emergent decision-making, serving as a source for lessons learned, and enhancing user engagement through dynamic interactions.", "line_start": 289, "line_end": 295, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.0, 0.2, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0024", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To design agent voices, assign each agent a persona including tone, quirks, and signature phrases to make conversations interesting.", "line_start": 290, "line_end": 292, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0025", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To make agent conversations engaging, design a distinct 'persona' for each agent, including a specific tone, quirks, and signature phrases.", "line_start": 299, "line_end": 300, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.0, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0026", "source_id": "SOURCE-20260207-016", "category": "claim", "content": "Differing viewpoints among AI agents are crucial for valuable conversations.", "line_start": 319, "line_end": 320, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0027", "source_id": "SOURCE-20260207-016", "category": "framework", "content": "Agent personas can be defined with a display name, tone (e.g., 'direct, results-oriented'), a quirk (e.g., 'Always asks for deadlines'), and a systemDirective (a prompt for the AI describing its personality and speaking style).", "line_start": 326, "line_end": 343, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.1, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0028", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To generate a systemDirective for an AI agent, describe the desired personality in one sentence and use an AI coding assistant to expand it into a complete prompt.", "line_start": 347, "line_end": 349, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.4, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0029", "source_id": "SOURCE-20260207-016", "category": "framework", "content": "Three essential conversation formats for AI agents are: Standup (4-6 agents, 6-12 turns, coordinator speaks first, purpose: align priorities), Debate (2-3 agents, 6-10 turns, temperature 0.8 for creativity/conflict, purpose: resolve disagreements), and Watercooler (2-3 agents, 2-5 turns, temperature 0.9 for casualness, purpose: generate insights from informal chat).", "line_start": 353, "line_end": 376, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0030", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To simulate realistic conversation flow among AI agents, use weighted randomness for speaker selection, where weights are influenced by factors like affinity to the last speaker, recency of speaking, and a random jitter.", "line_start": 393, "line_end": 406, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.4, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0031", "source_id": "SOURCE-20260207-016", "category": "claim", "content": "Weighted randomness in speaker selection makes AI agent conversations feel more real, allowing agents with good relationships to riff off each other while still enabling unexpected participants.", "line_start": 408, "line_end": 410, "chaperone": {"context_type": "anecdote", "argument_role": "evidence", "tension_vector": [0.3, 0.4, 0.1, 0.2, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0032", "source_id": "SOURCE-20260207-016", "category": "framework", "content": "An AI agent daily schedule can be designed with 24 time slots, assigning different conversation formats (e.g., Morning Standup, Afternoon Deep-dive, Evening Watercooler) and probabilities (40%-100%) to each slot to create a natural rhythm.", "line_start": 412, "line_end": 422, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0033", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To orchestrate AI agent conversations, a worker polls a queue for tasks, generates dialogue turn by turn using LLM calls, caps each turn at 120 characters to enforce human-like brevity, extracts memories, and fires events for frontend visibility.", "line_start": 428, "line_end": 435, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0034", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "When prototyping an AI roundtable conversation worker, describe desired conversation formats and agent voice descriptions, then instruct an AI coding assistant to build the worker using a specified queue system (e.g., Supabase) and turn-by-turn LLM generation.", "line_start": 454, "line_end": 458, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.4, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0035", "source_id": "SOURCE-20260207-016", "category": "claim", "content": "AI agents without memory will repeatedly make the same mistakes or suggestions, such as suggesting more weekend posts despite previous low engagement.", "line_start": 462, "line_end": 464, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.6, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0036", "source_id": "SOURCE-20260207-016", "category": "framework", "content": "Five types of memory for AI agents include: insight (discovery, e.g., 'Users prefer tweets with data'), pattern (pattern recognition, e.g., 'Weekend posts get 30% less engagement'), and strategy (strategy summary, e.g., 'Teaser before main post works better').", "line_start": 466, "line_end": 475, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0037", "source_id": "SOURCE-20260207-016", "category": "framework", "content": "There are 5 types of agent memory: insight (discovery), pattern (pattern recognition), strategy (strategy summary), preference (preference record), and lesson (lesson learned from failure).", "line_start": 470, "line_end": 479, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0038", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To implement agent memory, store memories in a database table (e.g., `ops_agent_memory`) with fields for `agent_id`, `type`, `content`, `confidence`, `tags`, `source_trace_id` (for idempotent deduplication), and `superseded_by` (for versioning).", "line_start": 483, "line_end": 494, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0039", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Memories can be distilled from conversation history by sending the full conversation to an LLM, instructing it to extract insights, patterns, or lessons in a JSON format.", "line_start": 500, "line_end": 511, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0040", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Implement idempotent deduplication for memories using a `source_trace_id` to prevent duplicate writes, especially when processes run periodically.", "line_start": 513, "line_end": 517, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0041", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "When distilling memories, enforce constraints such as a maximum number of memories per conversation (e.g., 6), a minimum confidence threshold (e.g., 0.55), and a cap on total memories per agent (e.g., 200, overwriting oldest).", "line_start": 520, "line_end": 524, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0042", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Agents can learn from outcomes by periodically fetching performance data (e.g., tweet metrics), calculating a baseline (e.g., median engagement rate), and writing 'lesson' memories with varying confidence based on strong or weak performance relative to the baseline.", "line_start": 529, "line_end": 539, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0043", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To ensure memories influence agent behavior without stifling exploration, implement a probabilistic mechanism (e.g., 30% chance) where memories (strategies, lessons) can override or enrich topic selection, while allowing a baseline behavior for the remaining percentage.", "line_start": 549, "line_end": 569, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.1, 0.3, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0044", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Optimize memory queries by using a cache (e.g., `Map<agentId, MemoryEntry[]>`) at the entry point of trigger evaluation, ensuring that an agent's memories are fetched from the database only once per evaluation cycle.", "line_start": 575, "line_end": 580, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0045", "source_id": "SOURCE-20260207-016", "category": "concept", "content": "Agent memory is structured knowledge distilled from experience, distinct from chat history, with each memory having a type, confidence score, and tags for efficient retrieval.", "line_start": 599, "line_end": 603, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0046", "source_id": "SOURCE-20260207-016", "category": "framework", "content": "An affinity system for agents tracks relationships between pairs of agents with an affinity value (0.10-0.95), total interactions, positive interactions, negative interactions, and a drift log.", "line_start": 610, "line_end": 620, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0047", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "When storing agent relationships, use a `CHECK(agent_a < agent_b)` constraint on agent IDs to ensure alphabetical ordering and prevent duplicate records for the same pair (e.g., 'analyst-boss' vs. 'boss-analyst').", "line_start": 622, "line_end": 626, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0048", "source_id": "SOURCE-20260207-016", "category": "framework", "content": "An agent system can be initialized with 6 agents and 15 pairwise relationships, each having an initial affinity and a backstory, with deliberate low-affinity pairs to generate interesting conversations.", "line_start": 626, "line_end": 634, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0049", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Deliberately create initial low-affinity pairs between agents to foster more interesting conversations, debates, and conflict resolution, as universally high affinity can lead to boring interactions.", "line_start": 634, "line_end": 637, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.3, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0050", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "When setting up agent relationships, deliberately create a few \"low affinity\" pairs to produce more interesting conversations during debates and conflict resolution, as high affinity among all agents leads to boring interactions.", "line_start": 636, "line_end": 639, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0051", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Implement a relationship drift mechanism where an LLM call for memory distillation also outputs pairwise relationship drift, with strict rules: max drift Â±0.03 per conversation, affinity floor 0.10, affinity ceiling 0.95, and keeping the last 20 drift_log entries.", "line_start": 643, "line_end": 669, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0052", "source_id": "SOURCE-20260207-016", "category": "framework", "content": "Agent affinity affects system behavior by influencing speaker selection (higher affinity, more likely to respond), conflict resolution (low-affinity pairs are automatically paired for conflict resolution), mentor pairing (high affinity + experience gap leads to mentoring conversations), and conversation tone (prompt's interaction type adjusts based on affinity, e.g., high tension leads to 'challenge' or 'critical', low tension to 'supportive' or 'agreement').", "line_start": 673, "line_end": 689, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0053", "source_id": "SOURCE-20260207-016", "category": "concept", "content": "An \"Initiative\" in an agent system refers to agents proactively proposing actions or ideas, in contrast to working reactively based on triggers, analogous to senior employees proposing plans versus junior employees waiting for assignments.", "line_start": 695, "line_end": 699, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.4, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0054", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To implement an initiative system for agents, separate the lightweight enqueueing process (Heartbeat) from the heavy LLM-based generation process (VPS worker) to avoid Vercel function timeouts and ensure reliability, where Heartbeat identifies agents due for an initiative and enqueues them, and a VPS worker consumes the queue to generate proposals using a cheap and fast LLM.", "line_start": 701, "line_end": 714, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.2, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0055", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To ensure valuable initiative proposals from agents, set enqueue conditions such as a cooldown (max 1 per 4 hours) and prerequisites like having at least 5 high-confidence memories and outcome lessons, ensuring the agent has sufficient \"accumulated experience.\"", "line_start": 716, "line_end": 723, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0056", "source_id": "SOURCE-20260207-016", "category": "claim", "content": "An agent without enough experience will propose generic, surface-level ideas.", "line_start": 725, "line_end": 726, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.6, 0.3, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0057", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Derive action items from specific conversation formats like standup, war_room, and brainstorm, but not informal chats, by piggybacking on the memory distillation LLM call to generate action items with titles, assigned agents, and step kinds, converting a maximum of 3 action items per day into missions.", "line_start": 729, "line_end": 745, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0058", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Ensure that all steps of the agent initiative process, including agents proposing their own work, go through full proposal-service gates (quota checks, auto-approve, cap gates) to maintain safety mechanisms.", "line_start": 747, "line_end": 749, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0059", "source_id": "SOURCE-20260207-016", "category": "concept", "content": "Voice Evolution for agents means their speaking style changes to reflect accumulated experience, similar to how a human's communication style adapts based on their work experience (e.g., data analysts lead with numbers, customer service becomes more patient).", "line_start": 753, "line_end": 759, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.4, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0060", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To implement agent voice evolution, derive personality dynamically from existing memory tables by calculating voice modifiers based on an agent's memory distribution (e.g., lesson count, tags, pattern count) before each conversation, rather than storing a separate personality score.", "line_start": 763, "line_end": 770, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.5, 0.4, 0.2, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0061", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "To implement dynamic agent personality, use a rule-driven system to derive 'voice modifiers' based on agent statistics, then inject these modifiers into the agent's system prompt before a conversation begins.", "line_start": 773, "line_end": 800, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0062", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Use rule-driven logic instead of LLMs for deriving agent voice modifiers because rules are deterministic, cost nothing, and are debuggable, preventing unpredictable results or hallucinations.", "line_start": 782, "line_end": 786, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.2, 0.6, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0063", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Inject derived voice modifiers into an agent's system prompt before a conversation starts by appending them to the base voice's system directive.", "line_start": 789, "line_end": 794, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0064", "source_id": "SOURCE-20260207-016", "category": "claim", "content": "Rule-driven systems for deriving agent personality modifiers are deterministic, cost-effective (zero additional LLM calls), and debuggable, unlike LLM-based approaches which can hallucinate or be difficult to trace.", "line_start": 802, "line_end": 808, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.2, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260207-016-0065", "source_id": "SOURCE-20260207-016", "category": "praxis_hook", "content": "Cache an agent's voice modifiers once per conversation to avoid re-querying them on every turn.", "line_start": 809, "line_end": 811, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
