{"atom_id": "ATOM-SOURCE-undated-016-0001", "source_id": "SOURCE-undated-016", "category": "claim", "content": "The primary challenge after building a single agent is enabling multiple agents to collaborate effectively without excessive token usage or coordination issues.", "line_start": 1, "line_end": 3, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0002", "source_id": "SOURCE-undated-016", "category": "claim", "content": "Single agents quickly reach limitations due to context window saturation, unclear decision-making, and debugging difficulties.", "line_start": 7, "line_end": 8, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.3, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0003", "source_id": "SOURCE-undated-016", "category": "claim", "content": "Multi-agent systems address single-agent limitations by distributing work among specialized agents, mirroring human team structures.", "line_start": 8, "line_end": 10, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.4, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0004", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Benefits of multi-agent systems include specialization (agents master one domain), parallel processing (simultaneous work on subtasks), maintainability (easier to identify and fix issues), and scalability (adding new capabilities by adding agents).", "line_start": 12, "line_end": 18, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.4, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0005", "source_id": "SOURCE-undated-016", "category": "claim", "content": "The primary tradeoff of multi-agent systems is increased coordination overhead, requiring agents to communicate, share state, and avoid conflicts.", "line_start": 19, "line_end": 21, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.4, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0006", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Three proven orchestration patterns for coordinating multiple agents are the Supervisor Pattern, Swarm Pattern, and Hierarchical Pattern, chosen based on coordination needs.", "line_start": 23, "line_end": 25, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0007", "source_id": "SOURCE-undated-016", "category": "framework", "content": "The Supervisor Pattern involves a central supervisor agent that decomposes tasks, routes to worker agents, validates outputs, and synthesizes the final response.", "line_start": 27, "line_end": 30, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0008", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Use the Supervisor Pattern for tasks with clear subtask decomposition, when auditability and reasoning transparency are needed, when quality control is prioritized over speed, and for coordinating 3-8 worker agents.", "line_start": 31, "line_end": 35, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.6, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0009", "source_id": "SOURCE-undated-016", "category": "claim", "content": "Supervisors in the Supervisor Pattern can become bottlenecks, leading to serial processing for coordination steps and increased token costs with more coordination layers.", "line_start": 54, "line_end": 56, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.4, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0010", "source_id": "SOURCE-undated-016", "category": "framework", "content": "The Swarm Pattern is a peer-to-peer orchestration where agents communicate directly, exchange information, and self-organize without a central controller.", "line_start": 58, "line_end": 60, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0011", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Use the Swarm Pattern when tasks benefit from multiple perspectives, lack clear serial decomposition, require real-time responsiveness, and agents need to react to each other's work.", "line_start": 61, "line_end": 65, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0012", "source_id": "SOURCE-undated-016", "category": "claim", "content": "The Swarm Pattern can lead to unpredictable emergent behavior, including duplicated work, infinite loops, or suboptimal solutions, making debugging difficult due to complex information flow.", "line_start": 84, "line_end": 87, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.3, 0.6, 0.2, 0.6, 0.3, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0013", "source_id": "SOURCE-undated-016", "category": "framework", "content": "The Hierarchical Pattern is a recursive Supervisor Pattern with multiple layers, where a top-level agent manages mid-level agents, which in turn manage worker agents.", "line_start": 89, "line_end": 91, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0014", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Use the Hierarchical Pattern for tasks too complex for flat supervision, when different domains require distinct management strategies, for coordinating 10+ agents, and when both strategic and tactical control are needed.", "line_start": 92, "line_end": 96, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0015", "source_id": "SOURCE-undated-016", "category": "claim", "content": "The Hierarchical Pattern can cause token costs to explode due to coordination overhead at each layer, only justified for complexity that flat patterns cannot handle.", "line_start": 120, "line_end": 122, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.4, 0.6, 0.1, 0.2, 0.3, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0016", "source_id": "SOURCE-undated-016", "category": "concept", "content": "Agent communication strategies define how information flows between agents, complementing orchestration patterns that define structural relationships.", "line_start": 124, "line_end": 125, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0017", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Shared State is a communication strategy where all agents read from and write to a common state object, making changes visible to everyone.", "line_start": 127, "line_end": 128, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.7, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0018", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Advantages of Shared State include simple implementation, easy debugging by inspecting state, and no message passing complexity.", "line_start": 139, "line_end": 141, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.6, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0019", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Disadvantages of Shared State include potential for race conditions with simultaneous writes, lack of isolation between agent contexts, and unbounded state growth without pruning.", "line_start": 142, "line_end": 144, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.4, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0020", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Start with Shared State for most agent systems until specific problems arise that it cannot solve.", "line_start": 145, "line_end": 146, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0021", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Message Passing is an event-driven communication strategy where agents send messages to each other without direct state sharing.", "line_start": 148, "line_end": 149, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.6, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0022", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Advantages of Message Passing include loose coupling between agents, suitability for asynchronous work, and ease of adding new agents without modifying existing ones.", "line_start": 160, "line_end": 162, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0023", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Disadvantages of Message Passing include harder debugging due to tracing message flow, potential for message loops, and the need for infrastructure like an event bus or queues.", "line_start": 163, "line_end": 165, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.4, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0024", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Use Message Passing when agents are truly independent and should not be aware of each other, or when asynchronous processing across services is required.", "line_start": 166, "line_end": 167, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0025", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Handoff Mechanism is a communication strategy where one agent explicitly transfers control and context to another agent.", "line_start": 169, "line_end": 170, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.6, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0026", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Advantages of the Handoff Mechanism include clear control flow, easy auditing of agent actions, and preservation of context across agents.", "line_start": 184, "line_end": 186, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0027", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Disadvantages of the Handoff Mechanism include tight coupling between agents, serial processing by default, and overhead on every transition.", "line_start": 187, "line_end": 189, "chaperone": {"context_type": "consensus", "argument_role": "limitation", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.4, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0028", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Use the Handoff Mechanism when tasks must occur in a specific order and context needs to flow sequentially through the agent chain.", "line_start": 190, "line_end": 191, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.8, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0029", "source_id": "SOURCE-undated-016", "category": "concept", "content": "Multi-agent systems face the additional challenge of coordinating state among agents without duplication or conflicts, beyond the memory management of single agents.", "line_start": 193, "line_end": 195, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0030", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Session-Based Memory involves isolated state for each agent interaction session, which is merged back into shared memory upon completion.", "line_start": 197, "line_end": 198, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0031", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Multi-agent memory patterns include Session-Based Memory, Window Memory (Conversation Context), and Episodic Memory (Cross-Agent Learning).", "line_start": 198, "line_end": 200, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.5, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0032", "source_id": "SOURCE-undated-016", "category": "concept", "content": "Session-Based Memory involves each agent interaction having isolated state that merges back into shared memory upon completion.", "line_start": 198, "line_end": 200, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0033", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Session-Based Memory is useful for parallel agents that need to read shared context but make isolated changes, common in supervisor patterns where workers operate independently.", "line_start": 211, "line_end": 213, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0034", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Window Memory maintains a sliding window of recent exchanges across all agents, compressing or dropping older entries.", "line_start": 215, "line_end": 216, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0035", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Implement Session-Based Memory for parallel agents that need to read shared context but make isolated changes, common in supervisor patterns where workers operate independently.", "line_start": 215, "line_end": 217, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0036", "source_id": "SOURCE-undated-016", "category": "concept", "content": "Window Memory (Conversation Context) maintains a sliding window of recent exchanges across all agents, compressing or dropping oldest entries.", "line_start": 218, "line_end": 220, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0037", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Use Window Memory for long-running agent conversations where context is important but retaining all information is impractical, such as in RAG applications.", "line_start": 239, "line_end": 242, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0038", "source_id": "SOURCE-undated-016", "category": "concept", "content": "Episodic Memory stores interaction history between specific agents to enable learning from past coordination.", "line_start": 243, "line_end": 245, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.6, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0039", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Employ Episodic Memory for agents that frequently collaborate to allow them to improve based on successful past interactions.", "line_start": 259, "line_end": 261, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0040", "source_id": "SOURCE-undated-016", "category": "claim", "content": "Multi-agent systems significantly increase token consumption, potentially 10x the cost of a single-agent system for the same task due to coordination overhead.", "line_start": 265, "line_end": 267, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.4, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0041", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "To optimize token economics in multi-agent systems: cache supervisor instructions, compress worker outputs to structured data, execute agents in parallel, and use lazy agent activation.", "line_start": 276, "line_end": 281, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0042", "source_id": "SOURCE-undated-016", "category": "claim", "content": "Multiple LLM calls in multi-agent systems introduce significant latency, with each call adding 2-5 seconds, making serial processing detrimental to user experience.", "line_start": 283, "line_end": 285, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.4, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0043", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Always parallelize independent work in multi-agent systems to manage latency, as serial execution significantly increases total task time.", "line_start": 290, "line_end": 292, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0044", "source_id": "SOURCE-undated-016", "category": "claim", "content": "In multi-agent systems, one agent's failure can cascade throughout the system, unlike single-agent systems where failures are local.", "line_start": 295, "line_end": 297, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.4, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0045", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Common failure modes in multi-agent systems include poison pills (garbage output), deadlocks (circular dependencies), resource exhaustion (rate limits), and cascading failures (supervisor failure).", "line_start": 298, "line_end": 303, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.4, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0046", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Defend against multi-agent system failures by implementing timeouts at every layer, circuit breakers after N failures, graceful degradation, and isolating state to prevent corruption.", "line_start": 304, "line_end": 308, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0047", "source_id": "SOURCE-undated-016", "category": "claim", "content": "Multi-agent systems require robust monitoring and observability from day one to debug effectively.", "line_start": 310, "line_end": 311, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.4, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0048", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Essential metrics for multi-agent system observability include per-agent success rate, coordination overhead, token consumption by agent, and agent interaction patterns.", "line_start": 313, "line_end": 317, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.6, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0049", "source_id": "SOURCE-undated-016", "category": "framework", "content": "Common anti-patterns in multi-agent systems include over-coordination, creating 'kitchen sink' agents, synchronous execution, ignoring costs, and lacking fallbacks.", "line_start": 354, "line_end": 362, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.4, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0050", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Use the Supervisor pattern when auditability is needed, tasks decompose clearly, with 3-8 specialized agents, and quality is prioritized over speed.", "line_start": 364, "line_end": 368, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0051", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Use the Swarm pattern when multiple perspectives are needed, there's no clear task decomposition, real-time responsiveness is critical, and agents can self-organize.", "line_start": 369, "line_end": 373, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.6, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0052", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Use the Hierarchical pattern when managing 10+ agents, multiple layers of abstraction are needed, both strategic and tactical control are required, and token costs are acceptable.", "line_start": 374, "line_end": 378, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.4, 0.5, 0.1, 0.2, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0053", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Use a single agent when the task is simple enough, one domain of expertise is sufficient, minimizing costs is important, or when the multi-agent approach is not yet clear.", "line_start": 379, "line_end": 383, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0054", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "When starting with multi-agent systems, pick the simplest pattern, typically the supervisor pattern: build one capable agent, identify its struggles, extract that into a second agent, add a supervisor, and iterate.", "line_start": 385, "line_end": 390, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.7, 0.1, 0.1, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-undated-016-0055", "source_id": "SOURCE-undated-016", "category": "praxis_hook", "content": "Build one system that uses two agents reliably before attempting to build ten.", "line_start": 395, "line_end": 395, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.1, 0.8, 0.1, 0.1, 0.9, 0.9], "opposes_atom_ids": []}, "extensions": {}}
