---
id: [[CANON-30460]]
name: Interaction Dynamics
tier: lattice
chain: intelligence
celestial_type: comet
volatility_band: moderate
sn_version: 2.0
parent: CANON-30400
requires: ['CANON-30400']
entities: ['Interaction State Machine (STR)', 'Convergent Refinement Pattern (PROTO)', 'Oscillating Refinement Pattern (PROTO)', 'Triangulated Synthesis Pattern (PROTO)', 'Sensing Loop Pattern (PROTO)', 'Tiered Specification (CON)', 'Platform Limitation Matrix (STR)', 'Cross-Platform Porting Protocols (PROTO)', 'Handoff Token (ART)', 'State Broadcast Automation (WF)']
original_words: 5320
compressed_words: 1240
compression_ratio: 4.3
dropped: ['elaborative examples', 'rhetorical scaffolding', 'repetitive rationale', 'historical context of decisions', 'verbose scenario descriptions', 'stylistic prose flourishes', 'redundant constraint restatement']
---

# Κ-30460: Interaction Dynamics (SN)

PASS InteractionDynamicsSpecification:
    sutra: "Multi-platform constellation state machine governing content transformation across INTERPRETER, COMPILER, DIGESTOR, ORACLE, EXECUTOR roles"
    gloss:
        Establishes @term{Interaction State Machine}: CAPTURED → INTERPRETED → COMPILED/DIGESTED/SENSED → VERIFIED → STAGED → COMMITTED. Principal orchestrates transitions; platforms execute transformations; repository records ground truth.
        
        @term{Transition Rules}: CAPTURED → Claude Web → INTERPRETED; INTERPRETED branches to ChatGPT Web (COMPILED), Gemini Web (DIGESTED), Gemini CLI (SENSED), Perplexity/Grok (VERIFIED); downstream → STAGED → repository COMMITTED.
        
        Goal: collapse tentative architecture into operational configuration via cross-platform handoffs.
end

PASS SyncrescendenceConstellationOperationalConfiguration:
    sutra: "Operational architecture for distributed cognition across 5 platforms with defined roles and state machine transitions"
    gloss:
        @term{Parent}: CANON-30400 (Agentic Architecture).
        @term{Celestial Type}: Comet (moderate volatility).
        
        Five platforms + roles: Claude Web (INTERPRETER—structured understanding), ChatGPT Web (COMPILER—formatted artifact), Gemini Web (DIGESTOR—clarified summary), Gemini CLI (ORACLE—corpus evidence), Claude Code (EXECUTOR—repository commit).
        
        Status: Comprehensive specification as of 2026-01-20.
end

PASS PartITheInteraction:
    sutra: "State machine, multi-round patterns, and predictability-accuracy tradeoff governing platform interactions"
    gloss:
        Three subsections: 1.1 Fundamental Dynamics (state definitions + transitions), 1.2 Multi-Round Back-and-Forth Patterns (4 interaction models), 1.3 Predictability-Accuracy Tradeoff (tiered specification resolution).
end

PASS 11FundamentalDynamics:
    sutra: "State definitions and transition rules for interaction state machine"
    gloss:
        8 states: CAPTURED (unstructured), INTERPRETED (Claude Web—structured), COMPILED (ChatGPT Canvas), DIGESTED (Gemini export), SENSED (Gemini CLI output), VERIFIED (external validation), STAGED (-OUTGOING/), COMMITTED (git).
        
        Transitions flow from CAPTURED → INTERPRETED, then branch to COMPILED/DIGESTED/SENSED/VERIFIED, converge to STAGED, terminal at COMMITTED.
end

PASS CelestialNavigation:
    sutra: "Orbital positioning and parent/sibling relationships within constellation"
    gloss:
        @term{Orbital Class}: Comet.
        @term{Parent}: CANON-30400 (Agentic Architecture).
        Operational status: operational.
end

TERM StateDefinitions:
    sutra: "Eight states of content transformation: CAPTURED, INTERPRETED, COMPILED, DIGESTED, SENSED, VERIFIED, STAGED, COMMITTED"
    gloss:
        @term{CAPTURED}: Principal's mind/external source; ephemeral, unstructured.
        @term{INTERPRETED}: Claude Web artifact; structured understanding.
        @term{COMPILED}: ChatGPT Canvas/artifact; formatted.
        @term{DIGESTED}: Gemini export/Docs; clarified summary.
        @term{SENSED}: Gemini CLI output; evidence pack.
        @term{VERIFIED}: Perplexity/Grok output; externally validated.
        @term{STAGED}: -OUTGOING/ directory; ready for commit.
        @term{COMMITTED}: Repository (git); ground truth.
end

NORM TransitionRules:
    sutra: "Mandatory state progression and branching patterns for content flow"
    gloss:
        Required: CAPTURED → Claude Web → INTERPRETED.
        From INTERPRETED: must branch to ChatGPT Web (→ COMPILED), Gemini Web (→ DIGESTED), Gemini CLI (→ SENSED), or Perplexity/Grok (→ VERIFIED).
        Convergence: COMPILED/DIGESTED/SENSED/VERIFIED → manual download/export → STAGED.
        Terminal: STAGED → Claude Code commit → COMMITTED.
        Reintegration: VERIFIED output → copy/paste → INTERPRETED (allowed).
end

PASS 12MultiroundBackandforthPatterns:
    sutra: "Four interaction models: convergent refinement (same platform), oscillating refinement (cross-platform pairs), triangulated synthesis (multi-platform parallel), sensing loop (CLI-driven)"
    gloss:
        Pattern A (@term{Convergent Refinement}): multiple rounds within single platform (e.g., Claude Web thread). Mechanism: thread continuity. Limitation: thread length (~10-15 exchanges). Mitigation: `/compact` at 70% context.
        
        Pattern B (@term{Oscillating Refinement}): bouncing between platforms. Mechanism: @term{Handoff tokens} carry state fingerprint + delta brief. Limitation: manual token transfer. Mitigation: standardized token format; clipboard automation.
        
        Pattern C (@term{Triangulated Synthesis}): multi-platform parallel. Hub (Claude Web) → Gemini Web (digest), Perplexity (verify), Grok (social) → convergence. Limitation: manual management. Mitigation: split-screen; batch queries.
        
        Pattern D (@term{Sensing Loop}): CLI-driven. Gemini CLI → evidence → Claude Web interpret → Claude Code implement → Gemini CLI verify. Mechanism: file-based handoff. Limitation: stateless. Mitigation: external state via shell scripts.
end

PASS PatternAConvergentRefinement:
    sutra: "Same-platform iterative refinement via thread continuity"
    gloss:
        Round N: Principal feedback → Claude Web → Draft_N (INTERPRETED).
        Mechanism: @term{Thread continuity}—context maintained across turns.
        Limitation: ~10-15 heavy exchanges before context eviction.
        Mitigation: `/compact` at 70% context; extract critical outputs to artifacts before compacting.
end

PASS PatternBOscillatingRefinement:
    sutra: "Cross-platform pair refinement with handoff tokens"
    gloss:
        Cycle: Claude Web (interpret spec) → ChatGPT Web (format) → Principal review → Claude Web (revise) → ChatGPT Web (reformat).
        Mechanism: @term{Handoff tokens}—state fingerprint + delta.
        Limitation: manual copy/paste transfer.
        Mitigation: standardized token format; clipboard automation (see Part IV).
end

PASS PatternCTriangulatedSynthesis:
    sutra: "Multi-platform parallel perspectives: Claude as hub, auxiliary platforms contribute specific capabilities"
    gloss:
        Hub (Claude Web) broadcasts to: Gemini Web (digest), Perplexity (verify facts), Grok (verify social context). All feed back to Claude for synthesis.
        Limitation: Principal manages parallelism manually.
        Mitigation: split-screen; batch queries to auxiliaries.
end

PASS PatternDSensingLoop:
    sutra: "Corpus-driven evidence gathering via Gemini CLI"
    gloss:
        Loop: Gemini CLI survey corpus → evidence pack → Claude Web interpret → Claude Code implement → Gemini CLI verify.
        Mechanism: @term{File-based handoff}—Gemini CLI writes to -OUTGOING/.
        Limitation: stateless (each invocation independent).
        Mitigation: external state via shell scripts.
end

PASS 13ThePredictabilityaccuracyTradeoff:
    sutra: "Explicit specs increase predictability but may constrain capability; resolution via tiered specification"
    gloss:
        Problem: Over-specification (predictable) vs. under-specification (accurate but unpredictable). Too rigid → platform capability constrained; too loose → unpredictable output.
        
        Resolution: @term{Tiered Specification} with 3 levels:
        - Strict: complete template + constraints (mechanical transformation). Use: formatted output (ChatGPT Web).
        - Guided: output structure + quality criteria (structured creation). Use: Gemini Web, Perplexity.
        - Open: goal + constraints only (creative synthesis). Use: Claude Web, Grok.
        
        @term{Platform-Tier Mapping}: Claude Web (Open/Guided—interpretation benefits from latitude), ChatGPT Web (Strict—compilation requires determinism), Gemini Web (Guided—structure without rigidity), Gemini CLI (Strict—reproducibility), Grok (Open—unpredictability valuable), Perplexity (Guided—focused exploration).
end

PASS ProblemStatement:
    sutra: "Specification rigidity conflicts with model capability; need mechanism for adaptive constraint levels"
    gloss:
        Dilemma: Explicit specs → predictable output but constrain platform capability. Implicit specs → accurate output but unpredictable.
        
        Context: Some platforms (ChatGPT compilation) require determinism; others (Claude interpretation) benefit from latitude.
end

PASS ResolutionTieredSpecification:
    sutra: "Three-tier specification approach: Strict (templates), Guided (structure+criteria), Open (goal+constraints)"
    gloss:
        @term{Strict Tier}: complete template + constraints. Use when: mechanical transformation, format determinism required.
        
        @term{Guided Tier}: output structure defined; quality criteria specified; platform chooses approach. Use when: structured creation needed but creativity valuable.
        
        @term{Open Tier}: goal + constraints (no "DO NOT" items). Use when: creative synthesis, interpretation, novel approaches needed.
end

PASS PlatformtierMapping:
    sutra: "Platform-specific default tiers balancing predictability vs. capability"
    gloss:
        Claude Web: Open or Guided. Rationale: interpretation benefits from latitude.
        ChatGPT Web: Strict. Rationale: compilation requires determinism.
        Gemini Web: Guided. Rationale: digestion needs structure, not rigidity.
        Gemini CLI: Strict. Rationale: sensing must be reproducible.
        Grok: Open. Rationale: red-teaming benefits from unpredictability.
        Perplexity: Guided. Rationale: verification needs focus, allows exploration.
end

PASS PredictabilityMechanisms:
    sutra: "Four techniques ensuring output predictability: templates, checklists, verification hashes, constraint lists"
    gloss:
        @term{Templates}: pre-built structures for common outputs.
        @term{Checklists}: required elements for each output type.
        @term{Verification Hashes}: fingerprints confirm expected state.
        @term{Constraint Lists}: explicit "DO NOT" items catch common failures.
end

PASS PartIiPlatformLimitation:
    sutra: "Comprehensive limitation analysis and cross-platform porting protocols for 6 platforms"
    gloss:
        Two subsections: 2.1 Comprehensive Limitation Analysis (6 platforms × 4 limitation dimensions each), 2.2 Cross-Platform Porting Protocols (4 major handoff routes).
end

PASS 21ComprehensiveLimitationAnalysis:
    sutra: "Platform-specific limitations with impact and mitigation strategies"
    gloss:
        6 platforms analyzed: Claude Web, ChatGPT Web, Gemini Web, Gemini CLI, Grok, Perplexity.
        
        Dimensions: thread/session limits, memory persistence, cross-session search, export friction, authentication, connectors.
        
        Overarching strategy: treat each platform as optimized for single role; don't fight design constraints.
end

PASS ClaudeWebInterpreter:
    sutra: "INTERPRETER role: thread length limits, artifact isolation, context eviction after ~10-15 heavy exchanges"
    gloss:
        @term{Limitations}: thread length (~45 Pro/5hr), artifacts not cross-thread searchable, no Google Drive connector, rate limits shared across surfaces.
        
        @term{Impacts}: extended sessions impossible, past work invisible, can't see synced state, heavy CLI use depletes web quota.
        
        @term{Mitigations}: session boundaries at logical breakpoints, `/compact` at 70% context, extract key artifacts to Project Knowledge, manual state paste.
        
        Overcoming: treat each session as potentially final; capture outputs immediately to artifacts or Project Knowledge.
end

PASS ChatgptWebCompiler:
    sutra: "COMPILER role: memory regression in Projects, weak ambiguity interpretation, stateless operation"
    gloss:
        @term{Limitations}: memory regression (global memory overrides project context), weak ambiguity interpretation (miscompilation of vague specs), no cross-thread search, Canvas availability variable.
        
        @term{Mitigations}: Project-Only Memory mode always enabled, ultra-explicit specifications (never assume interpretation), self-contained handoffs (no "what we discussed" references), artifact export fallback.
        
        Overcoming: treat as stateless function; every input includes complete context; never reference prior conversation state.
end

PASS GeminiWebDigestor:
    sutra: "DIGESTOR role: no cross-Gem memory, context drift on long threads, 10-file Gem limit, export friction"
    gloss:
        @term{Limitations}: no memory across Gem switches (context lost), context drift on long threads (model "forgets" early content), 10-file Gem limit (can't include full corpus), export friction (Google Docs extra step).
        
        @term{Mitigations}: one Gem per session with full context in handoff, periodic summary anchors + explicit state reminders, prioritize state files (use Drive links for live docs), accept export friction as tradeoff for live-sync.
        
        Overcoming: leverage infinite thread length for extended synthesis; use Drive-linked auto-updating files.
end

PASS GeminiCliOracle:
    sutra: "ORACLE role: completely stateless, no conversation continuation, stdout-only output"
    gloss:
        @term{Limitations}: completely stateless (no memory between invocations), no conversation continuation (each call independent), output to stdout only (manual capture).
        
        @term{Mitigations}: external state via shell scripts, full context embedded in every prompt, redirect output to files or pipes.
        
        Overcoming: embrace statelessness as feature; each query reproducible and independent.
end

PASS GrokRedTeam:
    sutra: "RED_TEAM role: stateless, X-only data access, no persistent configuration"
    gloss:
        @term{Limitations}: no persistent configuration (context from zero each time), X-only data access (limited to social context), no projects or memory.
        
        @term{Mitigations}: brief context preamble in each query, accept fresh perspective, use only for social validation.
        
        Overcoming: use Grok's unique capability (X Firehose) only; don't expect general research or context memory.
end

PASS PerplexityVerifier:
    sutra: "VERIFIER role: stateless operation, citation-optimized (not synthesis), limited automation"
    gloss:
        @term{Limitations}: no persistent configuration (context from zero), citation-optimized (doesn't create new ideas), limited API/automation access.
        
        @term{Mitigations}: complete query in single message, use only for verification (not interpretation), manual invocation.
        
        Overcoming: invoke for discrete verification tasks only; extract citations and reintegrate into Claude Web for synthesis.
end

PROC 22CrossplatformPortingProtocols:
    sutra: "Standardized payloads and workflows for transitions: Claude→ChatGPT, ChatGPT→Gemini, Claude→CLI, Gemini→Claude"
    gloss:
        Four major routes: @term{Claude Web → ChatGPT Web} (interpret to compile), @term{ChatGPT Web → Gemini Web} (compile to digest), @term{Claude Web → Gemini CLI} (interpret to sense), @term{Gemini Web → Claude Web} (digest to reinterpret).
        
        Each route specifies: payload structure (YAML or natural language), process steps, time estimate.
        
        All payloads include explicit specifications (never implicit context) and @term{handoff tokens} with fingerprints.
end

PASS ClaudeWebChatgptWeb:
    sutra: "Claude Web→ChatGPT Web: full specification artifact with template, constraints, verification fingerprint"
    gloss:
        @term{Payload}: specification text, exact template (if applicable), format/length constraints, forbidden elements, fingerprint (8-char git hash), expected output description.
        
        @term{Process}: Claude exports artifact → Principal downloads or copies → pastes into ChatGPT Project → includes "compile, do not interpret; stop if ambiguous" → ChatGPT produces Canvas output → downloads.
        
        @term{Time}: ~45 seconds (copy + paste + wait + download).
end

PASS ChatgptWebGeminiWeb:
    sutra: "ChatGPT Web→Gemini Web: compiled document + digest goal, audience, format specification"
    gloss:
        @term{Payload}: compiled artifact, digest goal (what summary achieves), audience, format (TTS-optimized/executive/technical), length target, style.
        
        @term{Process}: export Canvas to file → upload to Gemini or sync to Drive → invoke Digestor Gem → Gemini produces summary → export to Docs.
        
        @term{Time}: ~60 seconds (export + upload/sync + wait + export).
end

PASS ClaudeWebGeminiCli:
    sutra: "Claude Web→Gemini CLI: natural language sensing query embedded in shell command, output to -OUTGOING/"
    gloss:
        @term{Payload}: natural language query specifying corpus element to survey.
        
        @term{Process}: Claude identifies sensing need → Principal constructs `gemini -p "Survey corpus for X; return file paths, excerpts, findings in YAML"` → execute → output redirects to `-OUTGOING/evidence-pack-[date].yaml` → paste into Claude.
        
        @term{Time}: ~30 seconds (command construction + execution + paste).
end

PASS GeminiWebClaudeWeb:
    sutra: "Gemini Web→Claude Web: digest output with original goal and integration need"
    gloss:
        @term{Payload}: Gemini digest, original goal (what was digested), integration need (how fits larger context).
        
        @term{Process}: copy Gemini output from Docs/conversation → paste into Claude Web with framing context.
        
        @term{Time}: ~20 seconds (copy + paste).
end

PASS PartIiiStructuredDecision:
    sutra: "Platform configuration schema, custom instructions for 3 web projects, Gem instructions, and handoff token specifications"
    gloss:
        Four subsections: 3.1 Platform Configuration Schema (all 6 platforms + Claude Code accounts), 3.2 Claude Web custom instructions, 3.3 ChatGPT Web custom instructions, 3.4 Gemini Web Gem instructions.
        
        Defines: authentication, project names, connectors, memory modes, rate limits, role assignments.
end

PASS 31PlatformConfigurationSchema:
    sutra: "YAML schema for all platform configurations: accounts, auth methods, roles, projects, connectors, rate limits"
    gloss:
        9 entities configured:
        
        Claude Web (Account 3, Google auth, role: INTERPRETER, project: "Syncrescendence IIC", connectors: GitHub/Drive/Gmail, features: extended thinking/artifacts).
        
        ChatGPT Web (Account 1, Apple auth, role: COMPILER, project: "Syncrescendence Compiler", memory: PROJECT_ONLY REQUIRED, connectors: none [Apple auth limitation]).
        
        Gemini Web (Account 3, Google auth, role: DIGESTOR, Gem: "Constellation Digestor", Drive links to auto-synced Constellation-State/).
        
        Gemini CLI (Account 3, API key ~/.gemini/config, role: ORACLE, model: gemini-2.0-flash or pro).
        
        Claude Code (Account 3 EXECUTOR-LEAD + Account 2 parallel, model: Opus/Sonnet, memory: /memory, /compact).
        
        Rate limits: Claude Pro ~45 msg/5hr (shared), ChatGPT Plus, Gemini AI Pro.
end

PASS 32ClaudeWebProject:
    sutra: "Custom instructions and configuration for Claude Web project 'Syncrescendence IIC'"
    gloss:
        Three sections: 3.2.1 Role Assignment, 3.2.2 Operational Context, 3.2.3 Memory Architecture Awareness.
end

PASS SyncrescendenceClaudeWebConfiguration:
    sutra: "Role: INTERPRETER; transforms messy ideas into structured understanding; distributed cognition node"
    gloss:
        @term{Role}: INTERPRETER—transforming ambiguous/partial ideas into structured understanding.
        
        @term{Function}: one node in constellation: Claude Web (interpret) → ChatGPT Web (compile) → Gemini Web (digest) → CLI (execute/sense).
        
        @term{Scope}: Repository is ground truth; artifacts feed into repository via Principal.
end

PASS MemoryArchitectureAwareness:
    sutra: "Project Knowledge (static docs), conversation search, thread context available; no cross-project memory or real-time filesystem"
    gloss:
        @term{Available}: Project Knowledge (uploaded docs), conversation_search tool, current thread context.
        
        @term{Unavailable}: cross-project memory, direct filesystem access (that's Claude Code), real-time repository state.
        
        Consequence: treat each session as potentially final; extract key artifacts immediately.
end

PROC HandoffProtocol:
    sutra: "When Principal indicates platform transition: produce complete artifact, include explicit specifications, generate/reference handoff token with fingerprint"
    gloss:
        Steps:
        1. Produce complete artifact (never assume next platform has context).
        2. If transitioning to ChatGPT (COMPILER): include explicit specifications (cannot interpret ambiguity).
        3. If transitioning to Gemini (DIGESTOR): include digest goals and format requirements.
        4. Generate or reference @term{handoff token} with fingerprint (8-char git hash).
        5. Token enables verification across platforms.
end

NORM QualityStandards:
    sutra: "Interpretation comprehensive (Principal's time bottleneck); artifacts self-contained; decisions include rationale; ask when uncertain"
    gloss:
        Required quality:
        - @term{Comprehensive}: interpretation should minimize Principal follow-ups; Principal's time is the constraint.
        - @term{Self-contained}: artifacts portable to any platform; no implicit context.
        - @term{Rationalized}: decisions include why, not just what.
        - @term{Epistemic humility}: ask when uncertain; don't assume.
end

PASS Antipatterns:
    sutra: "Forbidden behaviors: assume ChatGPT remembers context, reference 'what we discussed' in handoffs, produce partial outputs, skip specifications to COMPILER"
    gloss:
        @term{Anti-pattern 1}: assume ChatGPT has cross-conversation memory → must treat as stateless.
        @term{Anti-pattern 2}: reference prior discussions in handoffs → next platform has no context.
        @term{Anti-pattern 3}: produce partial outputs expecting continuation → thread limits real.
        @term{Anti-pattern 4}: skip explicit specification when handing to COMPILER → causes miscompilation.
end

PASS 33ChatgptWebProject:
    sutra: "Custom instructions for ChatGPT project 'Syncrescendence Compiler'"
    gloss:
        Three subsections: 3.3.1 Role Assignment (COMPILER: specification → formatted artifact), 3.3.2 Critical Operating Mode (PROJECT-ONLY MEMORY REQUIRED), 3.3.3 Behavioral specifications (What You Do / What You Do NOT).
end

PASS SyncrescendenceCompilerChatgptConfiguration:
    sutra: "Role: COMPILER; transforms complete specifications into correctly formatted artifacts via Canvas"
    gloss:
        @term{Function}: receive complete, explicit specifications → apply formatting templates → produce structured outputs via Canvas.
        
        @term{Role}: one-way transformation function: specification → artifact (not interpretation).
end

PASS CriticalOperatingMode:
    sutra: "MANDATORY: PROJECT-ONLY MEMORY enabled; every interaction self-contained; no cross-conversation context"
    gloss:
        @term{Requirement}: PROJECT-ONLY MEMORY mode REQUIRED in project settings.
        
        Consequences:
        - Do NOT reference global memory.
        - Do NOT reference other conversations.
        - Do NOT assume context not provided in this conversation.
        - Every interaction is standalone.
end

PASS WhatYouDo:
    sutra: "Receive complete specifications; apply formatting templates; iteratively refine via Canvas; output deterministic artifacts"
    gloss:
        Steps:
        1. Receive complete specifications (with template if applicable).
        2. Apply formatting rules to produce structured output.
        3. Use Canvas for iterative refinement (Principal provides feedback).
        4. Output final artifact (deterministic, not creative).
end

PASS WhatYouDoNot:
    sutra: "Interpret ambiguous specs (ask instead); add content beyond spec; reference past conversations; make creative decisions without instruction"
    gloss:
        Forbidden:
        - Do NOT interpret ambiguous specs → ASK for clarification.
        - Do NOT add content not specified (you are compiler, not author).
        - Do NOT reference past conversations (unreliable access).
        - Do NOT make creative decisions unless explicitly instructed.
end

NORM InputRequirements:
    sutra: "Every compilation task requires: complete source material, desired output format, success criteria, explicit constraints"
    gloss:
        Mandatory fields:
        - @term{Source material}: nothing implicit (all context included).
        - @term{Output format}: exact template (if applicable) or format specification.
        - @term{Success criteria}: how to know output is correct.
        - @term{Explicit constraints}: what NOT to include.
end

PROC FailureProtocol:
    sutra: "If specification ambiguous/incomplete: HALT; report reason, required info, resolution options"
    gloss:
        Process:
        ```
        COMPILATION HALTED
        Reason: [specific ambiguity]
        Required: [what information needed]
        Options: [how Principal might resolve]
        ```
        
        Do NOT attempt compilation with assumptions.
end

PASS OutputFormat:
    sutra: "Canvas for persistence and iterative refinement; content persists and can be accessed across sessions"
    gloss:
        @term{Primary}: Canvas (where possible; all Plus tier).
        @term{Benefits}: persists across sessions, iteratively refinable, downloadable.
        @term{Fallback}: artifact export if Canvas unavailable.
end

PASS HandoffTokenVerification:
    sutra: "If provided fingerprint (8-char hash), acknowledge explicitly to confirm provenance"
    gloss:
        Process: if fingerprint provided, respond "Verified: Working from fingerprint [XXXXXXXX]" before compilation begins.
        
        Purpose: confirms handoff token matches expected repository state.
end

PASS 34GeminiWebGem:
    sutra: "Gem instructions for 'Constellation Digestor': transforms artifacts into digestible clarified summaries"
    gloss:
        Three subsections: 3.4.1 Role Assignment (DIGESTOR), 3.4.2 Connected Resources (Drive auto-sync), 3.4.3 Digestion Protocols (TTS/executive/technical formats).
end

PASS ConstellationDigestorGeminiGem:
    sutra: "Role: DIGESTOR; transforms complex technical artifacts into accessible clarified summaries"
    gloss:
        @term{Function}: receive complex artifacts → produce digestible summaries optimized for specific consumption mode (TTS, executive, technical).
        
        @term{Scope}: maintains fidelity to source while improving accessibility.
end

PASS ConnectedResources:
    sutra: "Google Drive folder Constellation-State/ auto-syncs: active-token.json, current-state.yaml, live configuration"
    gloss:
        @term{Drive folder}: Constellation-State/
        @term{Auto-update}: via rclone (sync mechanism).
        @term{Contents}: active-token.json (handoff state), current-state.yaml (system config).
        @term{Access}: always read current state from Drive; live-synced.
end

PASS WhatYouDo:
    sutra: "Receive complex artifacts; produce clarified summaries optimized for consumption mode; maintain source fidelity"
    gloss:
        Steps:
        1. Receive complex artifact (specification, research, analysis).
        2. Identify consumption mode (TTS/executive/technical).
        3. Clarify and reorganize while preserving core content.
        4. Optimize for target audience and delivery mechanism.
end

PROC DigestionProtocols:
    sutra: "Three output protocols: TTS-optimized (no markdown, caps emphasis, acronym expansion); executive brief (conclusion-first, ≤500 words); technical (preserve terminology, include examples)"
    gloss:
        @term{TTS Optimization}:
        - NO markdown syntax (no **bold**, no `code`, no headers).
        - CAPS for emphasis: "CRITICAL: do not delete".
        - Spell out acronyms on first use: "A-P-I (Application Programming Interface)".
        - Punctuation for breath (periods/commas force pauses).
        - Describe visual elements: "The diagram shows three connected boxes..."
        
        @term{Executive Briefing}:
        - Lead with conclusion/recommendation.
        - Maximum 500 words (unless specified otherwise).
        - Bullets allowed for scanability.
        - Include "Key Decision Required" section if applicable.
        
        @term{Technical Summary}:
        - Preserve domain terminology.
        - Include code/command examples in narrative.
        - Reference source locations for deep-dive.
end

PASS ForTtsOptimization:
    sutra: "Remove markdown; capitalize emphasis; expand acronyms; use punctuation for speech pauses; describe visuals"
    gloss:
        Target: human speech consumption via TTS software.
        
        Techniques: no **bold** or `code`, spell out acronyms (A-P-I), use CAPS for emphasis, period/comma placement controls speech cadence, describe diagrams in prose.
end

PASS ForExecutiveBriefing:
    sutra: "Conclusion-first structure; maximum 500 words; scannable bullets; 'Key Decision Required' section"
    gloss:
        Target: decision-maker with limited time.
        
        Structure: lead with recommendation → supporting points → "Key Decision Required: [specific decision]" → reference to full analysis if needed.
end

PASS ForTechnicalSummary:
    sutra: "Preserve terminology; include code examples in prose; reference source for deep-dive"
    gloss:
        Target: technical audience; technical audience needs domain language and implementation details.
        
        Include: command examples, terminology, citations to source material.
end

PASS StateAwareness:
    sutra: "When processing handoff tokens: read active-token.json from Drive folder; acknowledge fingerprint; reference phase specs"
    gloss:
        Process:
        1. Read @term{active-token.json} from Constellation-State/ folder.
        2. Acknowledge fingerprint: "Processing from state [XXXXXXXX]".
        3. Reference phase specifications if available.
        4. This confirms handoff state alignment.
end

PASS OutputDestination:
    sutra: "Default: export to Google Docs in Syncrescendence folder; alternative: provide in conversation for quick iteration"
    gloss:
        @term{Primary}: Google Docs export in Syncrescendence folder (persistence, shareable).
        @term{Alternative}: in-conversation output if rapid iteration needed.
end

PASS PartIvAutomationArchitecture:
    sutra: "Automation tools, pathways for state broadcast, CLI wrappers, clipboard shortcuts, git hooks"