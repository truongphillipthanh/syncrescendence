{"atom_id": "ATOM-SOURCE-20260204-website-article-unknown-my_ai_had_already_fixed_the_code_every-0001", "source_id": "SOURCE-20260204-website-article-unknown-my_ai_had_already_fixed_the_code_every", "category": "concept", "content": "Compounding engineering is defined as building self-improving development systems where each iteration makes the next one faster, safer, and better.", "line_start": 35, "line_end": 36, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.8, 0.2, 0.1, 0.3, 0.7, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260204-website-article-unknown-my_ai_had_already_fixed_the_code_every-0002", "source_id": "SOURCE-20260204-website-article-unknown-my_ai_had_already_fixed_the_code_every", "category": "claim", "content": "Compounding engineering differs from typical AI engineering by focusing on long-term system improvement through memory and learning from every interaction (pull request, bug, code review), rather than just short-term gains from individual prompts.", "line_start": 38, "line_end": 42, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.2, 0.4, 0.6, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260204-website-article-unknown-my_ai_had_already_fixed_the_code_every-0003", "source_id": "SOURCE-20260204-website-article-unknown-my_ai_had_already_fixed_the_code_every", "category": "praxis_hook", "content": "To implement compounding engineering, an upfront investment is required to teach AI tools before they can self-improve.", "line_start": 48, "line_end": 49, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.3, 0.1, 0.3, 0.8, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260204-website-article-unknown-my_ai_had_already_fixed_the_code_every-0004", "source_id": "SOURCE-20260204-website-article-unknown-my_ai_had_already_fixed_the_code_every", "category": "praxis_hook", "content": "A workflow for building a 'frustration detector' using compounding engineering involves: 1. Providing a sample conversation showing frustration. 2. Prompting an AI (e.g., Claude) to write a test for it. 3. Using the AI to write code to pass the test. 4. Iterating with the AI to adjust the prompt and re-run the test until it passes. 5. Stress-testing the AI's output by running the test multiple times to check for consistency. 6. Asking the AI to analyze failures and improve the prompt using chain of thought reasoning. 7. Codifying the entire workflow into the system's permanent operating procedures.", "line_start": 51, "line_end": 54, "chaperone": {"context_type": "method", "argument_role": "evidence", "tension_vector": [0.7, 0.2, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
