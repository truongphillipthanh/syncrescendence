---
id: [[CANON-30300]]
name: Technology Stack Database
tier: lattice
chain: intelligence
celestial_type: comet
volatility_band: dynamic
sn_version: 2.0
parent: CANON-30000
requires: ['CANON-30000', 'CANON-30310', 'CANON-30320', 'CANON-30340']
entities: ['Technology Stack Database (TOOL)', 'Bedrock Tables (STR)', 'Settlement Tables (STR)', 'Primitive Tables (STR)', 'Intelligence Tables (STR)', 'Apparatus (CON)', 'Primitives (CON)', 'Navigation Specifications (WF)']
original_words: 5298
compressed_words: 1247
compression_ratio: 4.25
dropped: ['rhetorical elaboration', 'repeated examples', 'stylistic prose', 'detailed SQL syntax formatting', 'extended historical context']
---

# Κ-30300: Technology Stack Database (SN)

PASS P03TechnologyStackDatabase:
    sutra: "ASA-Model database transforms 447 apps, 42 models, 31 pricing entries into navigable intelligence system."
    gloss:
        Core @term Technology Stack Database implements seven-layer @term Constitutional Stack (L0-L6: Physical Substrate → Transduction → Perceptual → Interaction → Choreographic → Cognitive → Agentic) and @term Object Ontology (O.FN, O.SVC, O.WF, O.AGT, O.MOD, O.DP, O.SRF, O.SNS, O.ACT, O.GRD, O.EVL, O.CPL). Solves tool selection chaos by systematizing classification, relationships, and navigation. Status: Beta, schema complete, awaiting data migration. Dependencies: CANON-30000 (Intelligence Chain), derived-taxonomy (Commercial Seams).
end

PASS AsaImplementationForRational:
    sutra: "Database operationalizes ASA-Model architecture for tool discovery and workflow composition."
    gloss:
        Maps @term Constitutional Stack layers to application classification. @term Object Types define computational units (stateless functions, stateful services, orchestrated workflows, autonomous agents, trained models, governed data products, presentation surfaces, sensors, actuators, guard policies). Enables @term rational tool selection via capability-based search. Supports @term workflow crystallization by documenting @term apparatus patterns (writing, research, coding, design, analysis, communication).
end

PASS CelestialNavigation:
    sutra: "Lattice comet with asteroid children spanning migration, workflows, protocols, implementation patterns."
    gloss:
        Parent: CANON-30000 (Intelligence Chain). Children: CANON-30310 (Tech Stack Migration), CANON-30320 (Workflow Intelligence), CANON-30330 (Research Protocols), CANON-30340 (Implementation Patterns). Volatility: dynamic. Refresh: monthly.
end

PASS Purpose:
    sutra: "Render 447 fragmented app records, 42 model specs, 31 API pricing entries into coherent intelligence system."
    gloss:
        Transforms scattered CSV data into @term Architecture Intelligence. Enables @term rational tool selection (matching capability to context). Supports @term workflow optimization via @term apparatus crystallization (capture → process → present → orchestrate patterns). Implements @term apparatus detection system. Provides @term navigation specifications for querying by capability, context, primitive, cost.
end

PASS Scope:
    sutra: "Includes schemas, migrations, primitives, apparatus; excludes UI, scraping, real-time updates, community systems."
    gloss:
        Included: Complete database schema (6 bedrock tables, 11 settlement tables, 6 primitive tables, 7 intelligence tables). Migration protocol for Function.csv (447 apps), Models.csv (42 models), API.csv (31 pricing records). Primitive extraction framework (50+ features across 10+ categories). Apparatus detection (6 initial patterns). Excluded: Frontend implementation (specification only). Automated scraping. Real-time pricing. Community contributions (future).
end

PASS Included:
    sutra: "Schema, migration, primitives, apparatus, lifecycle management, navigation specs, integration points."
    gloss:
        Database schema: @term bedrock tables (layers L0-L6, roles, object types, modalities, lifecycle states, commercial seams, deployment contexts). @term Settlement tables (apps, models, pricing with 15+ pricing dimensions). @term Primitive tables (features, app-primitive relationships, dependencies). @term Intelligence tables (apparatus, components, app relationships, usage contexts, workflows). Lifecycle state management: experimental, active, @term primitive_repository, deprecated, archived. Navigation: 7 query patterns (capability search, context routing, primitive filtering, apparatus discovery, cost optimization, relationship navigation, workflow suggestion). Commercial seams: @term vector_db, @term api_router, @term inference_engine, @term observability, @term model_marketplace, @term edge_runtime, @term security_gateway.
end

PASS Excluded:
    sutra: "Frontend UI implementation, web scraping, automated updates, community contribution mechanisms."
    gloss:
        Not included: Functional frontend (specification provided, implementation deferred). Automated data collection/scraping systems. Real-time pricing synchronization. Community contribution workflows (future enhancement). User authentication/authorization layers.
end

PASS Limitations:
    sutra: "Classification accuracy depends on description quality; apparatus detection requires usage data; incomplete primitives initially."
    gloss:
        @term Classification subjectivity: Layer and object type assignments require judgment; edge cases inevitable. @term Primitive extraction incompleteness: Initial catalog will miss nuances; continuous discovery required. @term Apparatus patterns theoretical: Require real-world validation. @term Commercial volatility: Pricing/vendor relationships change faster than manual updates. @term Usage context data: Effectiveness scores estimated; need empirical validation. Maintenance burden risk: Must not exceed 4 hours/week.
end

PASS TheoreticalFoundation:
    sutra: "Database architecture mirrors ASA Model constitutional stack and implements geological metaphor."
    gloss:
        @term ASA Model seven-layer stack: L0 (silicon, power), L1 (sensors, actuators), L2 (visual/auditory design), L3 (gestures, language), L4 (navigation, state, sync), L5 (augmentation, reasoning, personalization), L6 (autonomous agents, coordination, alignment). @term Object Ontology: Functions (stateless), Services (stateful), Workflows (orchestrated), Agents (autonomous), Models (trained intelligence), Data Products (governed), Surfaces (display), Sensors/Actuators (I/O), Guards (policy). @term Geological metaphor: Bedrock (stable taxonomies: layers, roles, types, modalities). Settlements (dynamic instances: apps, models, pricing). Primitives (extractable features: vim motions, markdown rendering, sync). Intelligence (emergent patterns: apparatus, relationships, workflows).
end

PASS AsaModelIntegration:
    sutra: "Database structure operationalizes ASA-Model layers, object types, and constitutional framework."
    gloss:
        Each @term app classified by layer (L0-L6), @term role (capture, process, present, orchestrate), @term object type (O.MOD, O.SVC, O.WF, O.AGT, O.FN, O.DP). @term Models mapped to cognitive convergence layer (L5). @term APIs record inference engine participation and cost. @term Primitives track extractable features across apps. @term Apparatus patterns document multi-layer orchestration (e.g., writing apparatus: L2 editor → L4 sync → L6 agent automation).
end

PASS GeologicalModelMetaphor:
    sutra: "Schema separates stable bedrock (taxonomies), settlements (instances), primitives (features), intelligence (patterns)."
    gloss:
        @term Bedrock: Layers (L0-L6), Roles (capture, process, present), Object Types (O.MOD, O.SVC, O.FN, O.AGT, O.WF, O.DP, O.SRF, O.SNS, O.ACT, O.GRD, O.EVL, O.CPL), Modalities (text, voice, visual, gesture, haptic), Lifecycle States (experimental, active, primitive_repository, deprecated, archived), Commercial Seams (7 types), Deployment Contexts (cloud, on-premise, edge, hybrid). @term Settlements: Apps (447), Models (42), API Pricing (31), Relationships, Capabilities. @term Primitives: Features (vim_motions, markdown_render, real_time_sync, bidirectional_sync, offline_first, full_text_search, tag_system, link_system, api_access, webhook_support), with quality ratings and dependencies. @term Intelligence: Apparatus (6 patterns), Components, Usage Contexts, Workflows (10+).
end

PASS DatabaseSchema:
    sutra: "Normalized schema with 30 tables: 6 bedrock, 11 settlement, 6 primitive, 7 intelligence tables."
    gloss:
        @term Bedrock tables: layers (L0-L6), roles (functional roles), object_types (O.FN, O.SVC, O.WF, O.AGT, O.MOD, O.DP, O.SRF, O.SNS, O.ACT, O.GRD, O.EVL, O.CPL, 15 types), modalities (text, voice, visual, gesture, haptic), lifecycle_states (5 states), commercial_seams (7 seams), deployment_contexts (4 contexts). @term Settlement tables: apps (447, with layer, role, object_type, lifecycle, stage, url), app_modalities (m2m), app_commercial_seams (m2m), app_deployment_contexts (m2m), models (42, with context_window, capabilities: vision, extended_thinking, search), model_capabilities (m2m), api_pricing (31, with 18+ pricing dimensions: input/output tokens, volume pricing, cached input, prompt caching, audio, search). @term Primitive tables: primitives (50+, code, category, source, abstractable), app_primitives (m2m, quality ratings), primitive_dependencies. @term Intelligence tables: apparatus (6 patterns, frequency scores), apparatus_components (role, core flag), app_relationships (competes, requires, obsoletes, combines_with, 1-5 strength), usage_contexts (spatial, attentional, temporal, social), app_usage_contexts (effectiveness 1-5), workflow_templates (10+), workflow_steps (sequential, duration, i/o). Indexes: 16+ on search-critical fields. Foreign keys enforce referential integrity.
end

NORM DesignPrinciples:
    sutra: "Schema must be normalized, navigation-optimized, extensible, queryable for intelligence."
    gloss:
        @term Normalization: Separate stable taxonomies from volatile data. @term Navigation optimization: Indexes on all search-critical fields (app name/slug/layer/role/object_type/lifecycle/stage, model name/api_name/family/lab, primitive code/category/extractable, apparatus code/frequency). @term Extensibility: Flexible tagging (via relationships) and relationship systems (app_relationships, app_primitives, app_modalities). @term Queryability: Support complex cross-table analytics (cost per token, apparatus discovery, primitive overlap).
end

PASS BedrockTablesStableTaxonomies:
    sutra: "6 immutable taxonomy tables establish classification foundation: layers, roles, types, modalities, states, seams."
    gloss:
        @term Layers (7 tables): L0 (Physical Substrate), L1 (Transduction), L2 (Perceptual), L3 (Interaction), L4 (Choreographic), L5 (Cognitive), L6 (Agentic). @term Roles (hierarchical): capture, process, present, orchestrate, and domain-specific variants. @term Object Types (15 defined): O.MOD (model), O.SVC (service), O.WF (workflow), O.AGT (agent), O.FN (function), O.DP (data product), O.SRF (surface), O.SNS (sensor), O.ACT (actuator), O.INS (instrument), O.GRD (guard), O.EVL (evaluator), O.CPL (copilot). @term Modalities (5): text, voice, visual, gesture, haptic. @term Lifecycle States (5): experimental (1), active (2), @term primitive_repository (3), deprecated (4), archived (5). @term Commercial Seams (7): @term vector_db (high lock-in, per-query+storage), @term api_router (medium, per-request), @term inference_engine (medium, compute), @term observability (low, SaaS), @term model_marketplace (medium, fee), @term edge_runtime (low, license), @term security_gateway (medium, SaaS/self).
end

PASS SettlementTablesDynamicInstances:
    sutra: "11 volatile tables track 447 apps, 42 models, 31 pricing records with relationships and capabilities."
    gloss:
        @term Apps table (447 records): name, slug, layer_id, role_id, object_type_id, lifecycle_state_id, stage, url, last_reviewed. @term App modalities (m2m): primary flag. @term App commercial seams (m2m): role_in_seam. @term App deployment contexts (m2m): is_preferred. @term Models table (42 records): name, api_name, family (Claude 4, GPT-4, Llama), research_lab, context_window (tokens), output_token_limit, training_cutoff, release_date, supports_vision, supports_extended_thinking, supports_search. @term Model capabilities (m2m): modality_id. @term API pricing (31 records): input_token_price, output_token_price (base), 200K volume pricing, cached_input_price, prompt_caching (read/write, both regular+200K), audio pricing (input, cached input, output), search_price_per_1000, context_caching_storage_price, effective_date. All timestamped, nullable-robust.
end

PASS PrimitiveTablesFeatureExtraction:
    sutra: "3 tables catalog 50+ extractable features with quality, dependencies, and implementation tracking."
    gloss:
        @term Primitives table: code (unique), name, category (keybinding, rendering, collaboration, data_sync, search, organization, integration, export), description, source_app_id, extractable boolean, abstraction_level (atomic, compound, workflow), lifecycle_state_id. Initial set: vim_motions, markdown_render, real_time_sync, offline_first, bidirectional_sync, full_text_search, tag_system, link_system, api_access, webhook_support. @term App primitives (m2m): implementation_quality (excellent, good, adequate, poor), discovered_date. @term Primitive dependencies: depends_on_primitive_id, dependency_type (required, optional, enhances). Enables feature-level tool matching and apparatus composition.
end

PASS IntelligenceTablesEmergentPatterns:
    sutra: "7 tables track apparatus patterns, app relationships, usage contexts, and workflow templates."
    gloss:
        @term Apparatus (6 initial): writing (capture→draft→edit→publish), research (collect→annotate→connect→synthesize), coding (edit→test→debug→deploy), design (ideate→sketch→prototype→refine), analysis (import→clean→transform→visualize), communication (schedule→meet→document→archive). Frequency score 1-5. @term Apparatus components (m2m): role_in_apparatus, is_core. @term App relationships (m2m): relationship_type (powers, competes, requires, obsoletes, combines_with), strength 1-5, discovered_date. @term Usage contexts: code (mobile_capture, deep_analysis, rapid_synthesis), spatial (ambulatory, fixed, situated), attentional (divided, focused, immersive), temporal (reactive, deliberative, persistent), social (solitary, intimate, collaborative, public). @term App usage contexts (m2m): effectiveness_score 1-5. @term Workflow templates (10+ target): name, apparatus_id, use_frequency, average_duration_minutes. @term Workflow steps: sequential, app_id, action, i/o, duration. Supports pattern discovery and workflow suggestion.
end

PASS IndexesForNavigationPerformance:
    sutra: "16+ indexes optimize search performance on app names, layers, roles, models, primitives, relationships."
    gloss:
        @term App indexes: name, slug, layer_id, role_id, object_type_id, lifecycle_state_id, stage. @term Model indexes: name, api_name, family, research_lab. @term Primitive indexes: code, category, extractable. @term Apparatus indexes: code, frequency_score. @term Relationship indexes: relationship_type. @term Quality indexes: app_primitives.implementation_quality. Target query response: <100ms for standard searches.
end

PROC MigrationProtocol:
    sutra: "Six-phase, 9-11 hour migration: schema creation, bedrock population, settlement migration, primitives, apparatus, validation."
    gloss:
        @term Phase 1 (30 min): Execute schema SQL, verify foreign keys, test constraints. @term Phase 2 (1 hour): Populate bedrock (layers L0-L6, roles, 15 object types, 5 modalities, 5 lifecycle states, 7 commercial seams, 4 deployment contexts). @term Phase 3 (2-3 hours): Migrate 447 apps from Function.csv (map layer, role, object_type, stage, lifecycle_state; manual review required). Migrate 42 models from Models.csv (context_window, capabilities, training_cutoff, release_date). Migrate 31 API pricing records with 18 pricing dimensions. @term Phase 4 (3-4 hours): Extract 50+ primitives with categories, link to apps, identify dependencies. @term Phase 5 (2-3 hours): Detect 6 apparatus patterns, map app components, establish roles (capture, process, present, orchestrate). @term Phase 6 (1-2 hours): Validate data integrity (no orphaned records, no duplicates, 100% classification coverage). Quality metrics: apps classified, models complete, pricing records, primitives extracted, apparatus defined, relationships mapped.
end

PASS Phase1SchemaCreation:
    sutra: "Execute 30 SQL tables, verify constraints, establish foreign key integrity."
    gloss:
        Create all table definitions: 6 bedrock, 11 settlement, 6 primitive, 7 intelligence. Enable foreign key constraints. Test sample inserts. Verify schema inspection. Create backup protocol for rollback.
end

PASS Phase2BedrockPopulation:
    sutra: "Populate 7 layers, roles, 15 object types, 5 modalities, 5 lifecycle states, 7 seams, 4 contexts."
    gloss:
        @term Layers: L0-L6 with domains (mechanics, symbols, semantics, agency). @term Roles: hierarchical (capture, process, present, orchestrate). @term Object Types (15): O.FN, O.SVC, O.WF, O.AGT, O.MOD, O.DP, O.STM, O.ARC, O.SRF, O.SNS, O.ACT, O.INS, O.GRD, O.EVL, O.CPL, with typical_layers. @term Modalities (5): text, voice, visual, gesture, haptic. @term Lifecycle States (5): experimental, active, primitive_repository, deprecated, archived. @term Commercial Seams (7): vector_db (high lock-in), api_router (medium), inference_engine (medium), observability (low), model_marketplace (medium), edge_runtime (low), security_gateway (medium). @term Deployment Contexts (4): cloud, on_premise, edge, hybrid.
end

PASS Phase3SettlementMigration:
    sutra: "Migrate 447 apps, 42 models, 31 pricing records with classification and relationship mapping."
    gloss:
        @term Apps: Read Function.csv (Application, Description, Layer, Role, Stage). Map layer, role, object_type, lifecycle_state (manual review for accuracy). Extract url from notes. @term Models: Read Models.csv (Name, API, Family, Research Lab, Context Window, Output Limit, Training Cutoff, Release Date, Vision, Extended Thinking, Search). Assign O.MOD object type. @term Pricing: Read API.csv (model, api_name, input_token_price, output_token_price, volume pricing, cached input, prompt caching, audio pricing, search price, context caching). Link to model_id. Manual review required for layer and object_type accuracy.
end

PASS MappingFunctionsToBe:
    sutra: "Fuzzy matching logic for layer inference, object type keywords, role classification (to refine during actual migration)."
    gloss:
        @term Layer mapping: Fuzzy match from description text (Physical→L0, Transduction→L1, Perceptual→L2, Interaction→L3, Choreographic→L4, Cognitive→L5, Agentic→L6). @term Object type inference: Keyword matching (service→O.SVC, model→O.MOD, workflow→O.WF, agent→O.AGT, function→O.FN, data→O.DP, surface→O.SRF, sensor→O.SNS, actuator→O.ACT). @term Role mapping: Extract from function description or assign via layer/type heuristics. Refinement expected during live migration.
end

PASS MigrationScript:
    sutra: "Python scripts to parse CSVs, map fields, insert records, validate, report errors."
    gloss:
        Parse Function.csv (447 rows), Models.csv (42 rows), API.csv (31 rows). Apply mapping functions. Insert with transaction rollback on error. Validate: no NULL in required fields, foreign key integrity, duplicate detection. Report: migration statistics, error log, classification coverage.
end

PASS Phase4PrimitiveExtraction:
    sutra: "Identify 50+ features across 10+ categories from app descriptions; map to apps; link dependencies."
    gloss:
        Systematically extract primitives: @term Keybinding (vim_motions, emacs_commands, custom_shortcuts). @term Rendering (markdown, LaTeX, syntax_highlighting, diagrams). @term Collaboration (real_time_sync, conflict_resolution, presence_awareness). @term Data sync (bidirectional_sync, offline_first, version_control). @term Search (full_text, semantic, fuzzy). @term Organization (tags, hierarchies, links, databases). @term Integration (api_access, webhooks, automation). @term Export (formats, quality, metadata). Initial 10 primitives: vim_motions, markdown_render, real_time_sync, offline_first, bi_directional_sync, full_text_search, tag_system, link_system, api_access, webhook_support. Link each primitive to apps implementing it with quality rating (excellent, good, adequate, poor). Identify dependencies (e.g., real_time_sync requires conflict_resolution).
end

PASS Phase5ApparatusDetection:
    sutra: "Define 6+ apparatus patterns with component roles and frequency scores based on usage patterns."
    gloss:
        @term Writing apparatus (freq 5): Capture (Drafts, Apple Notes) → Process (Obsidian, VSCode) → Present (Ghost, Medium) → Orchestrate (Zapier). @term Research apparatus (freq 5): Collect → Annotate → Connect → Synthesize → Document. @term Coding apparatus (freq 5): Edit → Test → Debug → Deploy → Monitor. @term Design apparatus (freq 4): Ideate → Sketch → Prototype → Refine → Export. @term Analysis apparatus (freq 4): Import → Clean → Transform → Visualize → Report. @term Communication apparatus (freq 5): Schedule → Meet → Document → Follow-up → Archive. For each: identify core and optional app components, document roles, validate against usage data (future).
end

PASS Phase6ValidationQuality:
    sutra: "Verify data integrity, check for orphans/duplicates, validate classification coverage, quantify completeness."
    gloss:
        @term Integrity checks: Foreign key violations (apps.layer_id in layers, apps.object_type_id in object_types). Duplicate detection (name, api_name). Missing critical data (NULL counts). @term Coverage metrics: Apps classified X/447 (target 100%), models complete Y/42 (target 100%), pricing Z/31 (target 100%), primitives extracted N/50+ (target 50+), apparatus defined M/6+ (target 6+), relationships mapped R/200+ (target 200+). @term Quality: Zero foreign key violations, zero duplicates, <5% unknown classifications.
end

PASS NavigationSpecifications:
    sutra: "7 query patterns: capability search, context routing, primitive filtering, apparatus discovery, cost optimization, relationships, workflows."
    gloss:
        @term Capability search: "What apps can [perform function]?" Match by description, keywords, primitives, layer, role. @term Context routing: "Quick capture for mobile?" Filter by usage_context (spatial=ambulatory), role=capture, effectiveness>=4. @term Primitive filtering: "What has vim motions?" Join app_primitives.primitive_id where code=vim_motions, filter by quality. @term Apparatus discovery: "Show writing workflow" Join apparatus→apparatus_components→apps, order by role (capture→process→present→orchestrate). @term Cost optimization: "Cheapest long-context model?" Filter models.context_window>=200000, sort by (input_price*100000 + output_price*1000)/100k_tokens. @term Relationships: "Alternatives to Notion?" Filter app_relationships.relationship_type IN (competes, obsoletes). @term Workflows: "How to use Obsidian?" Join workflow_templates→workflow_steps→apps WHERE app=Obsidian.
end

NORM QueryInterfaceRequirements:
    sutra: "Navigation must support multi-faceted search, smart filtering, cost calculation, workflow suggestion."
    gloss:
        @term Required capabilities: (1) Keyword search across name, description, URL. (2) Faceted filters: layer, role, object_type, lifecycle_state, primitive, commercial_seam, deployment_context. (3) Context-aware routing: spatial (ambulatory/fixed), attentional (divided/focused), temporal (reactive/deliberative), social (solitary/collaborative). (4) Primitive-based matching with quality ratings. (5) Cost calculators: tokens per model, bulk pricing, total spend. (6) Relationship navigation: competes, requires, combines_with. (7) Workflow templates with step-by-step guidance. Response time: <100ms standard queries.
end

PASS InterfaceMockups:
    sutra: "CLI and web dashboard specifications for searching, filtering, discovering, comparing tools and models."
    gloss:
        @term CLI commands: search "markdown editor" (12 results), find --context ambulatory --role capture (Drafts, Apple Notes), primitives vim_motions (Obsidian, Neovim, VSCode+Vim), apparatus writing (step-by-step workflow), models compare --context-window 200000 --sort-by price. @term Web dashboard: Total apps 447, models 42, apparatus 6, primitives 50+. Search view with faceted filters. App detail: classification, description, primitives, relationships, apparatus, commercial, links. Apparatus view: visual workflow diagram, components, alternative paths, setup time. Model comparison: side-by-side specs, cost calculator, capability matrix, recommendations.
end

PASS CommandlineInterface:
    sutra: "CLI for search, navigation, primitive discovery, apparatus exploration, model comparison."
    gloss:
        Search: `$ techstack search "markdown editor"` → 12 results with layer, lifecycle, primitives. Find: `--context ambulatory --role capture` → effectiveness scores. Primitives: `primitives vim_motions` → list with quality (excellent/good/adequate). Apparatus: `apparatus writing` → capture/process/present/orchestrate steps. Models: `models compare --context-window 200000` → ranked by cost per 100K+1K tokens.
end

PASS BasicSearch:
    sutra: "Keyword search across app names, descriptions, URLs with layer and lifecycle filtering."
    gloss:
        Input: query string (e.g., "markdown editor"). Output: name, description, layer, lifecycle, primitives. Filter: lifecycle_state_id=active. Order: relevance or alphabetical. 12 results example shows Obsidian (L3, O.SRF, primitives: markdown_render/vim_motions/link_system) and Typora (L3, O.SRF, primitives: markdown_render/export_pdf).
end

PASS ContextbasedNavigation:
    sutra: "Context-aware routing: spatial, attentional, temporal, social parameters drive tool selection."
    gloss:
        Contexts: ambulatory (mobile), fixed (desktop), situated (embedded). Attentional: divided (background), focused (primary), immersive (all-in). Temporal: reactive (ad-hoc), deliberative (planned), persistent (always-on). Social: solitary, intimate, collaborative, public. Query: --context ambulatory --role capture → Drafts (effectiveness 5/5), Apple Notes (4/5). Joins usage_contexts → app_usage_contexts → apps, filters by spatial_context and role, orders by effectiveness_score DESC.
end

PASS PrimitiveSearch:
    sutra: "Feature-based discovery: which apps implement vim motions, markdown rendering, real-time sync, etc."
    gloss:
        Query: `primitives vim_motions` → Obsidian (excellent), Neovim (excellent), VSCode+Vim (good), Notion+Vim (adequate). Join app_primitives → primitives WHERE code='vim_motions'. Order by implementation_quality DESC. Shows implementation_notes. Enables @term primitive-first tool selection (find tools with specific features).
end

PASS ApparatusView:
    sutra: "Workflow discovery: complete apparatus from capture through orchestration with step roles and alternatives."
    gloss:
        Query: `apparatus writing` → Capture [Drafts (core), Apple Notes (optional)] → Process [Obsidian (core), VSCode (optional)] → Present [Ghost (core), Medium (optional)] → Orchestrate [Zapier (core)]. Join apparatus → apparatus_components → apps, order by role. Show is_core flag, usage_notes. Enable exploration of alternative paths (e.g., Medium instead of Ghost for present step).
end

PASS ModelComparison:
    sutra: "Side-by-side model specs and cost analysis: context window, capabilities, pricing, recommendations."
    gloss:
        Query: `models compare --context-window 200000 --sort-by price` → Claude Haiku 4 ($0.25 per 100K+1K), GPT-4o mini ($0.35), Claude Sonnet 4.5 ($0.80). Display: context_window, capabilities (vision, extended_thinking, search), input/output token price, volume pricing, effective_date. Cost calculator: estimate 100K input + 1K output → total cost. Capability matrix: which models support vision, extended thinking. Recommendations: "Best for long-context reasoning" flag.
end

PASS WebInterfaceSpecification:
    sutra: "Dashboard with search, faceted filters, app details, apparatus diagrams, model comparison, cost calculator."
    gloss:
        Dashboard: Counts (447 apps, 42 models, 6 apparatus, 50+ primitives). Search view: multi-faceted (name, description, layer, role, primitive, lifecycle, seam). App detail: classification (layer, role, object_type, lifecycle), description, primitives (with quality), relationships (competes/requires/combines_with), apparatus (which workflows), commercial (vendor, pricing model, lock-in), links (official URL, docs). Apparatus view: visual diagram (capture→process→present→orchestrate), components with roles, alternative paths, setup time/complexity. Model comparison: spreadsheet view (name, lab, family, context_window, vision/thinking/search flags, input/output price, volume discounts), cost calculator (tokens → $), capability matrix, recommendations. Responsive design (mobile/tablet/desktop).
end

PROC MaintenanceProtocols:
    sutra: "Weekly/monthly updates for models, pricing, apps; quarterly audits; data quality checks."
    gloss:
        @term Weekly: Check for new model releases, update API pricing, add discovered apps, refresh lifecycle states. @term Monthly: Extract primitives from new apps, validate apparatus patterns, map relationships, cost analysis. @term Quarterly: Comprehensive data audit, classification review, commercial landscape assessment, tool stack recommendations. Data collection workflows: new app (capture→classify→extract→relate→contextualize→lifecycle), new model (monitor→capture→pricing→classify→benchmark→recommend). QA: classification accuracy, completeness (100% coverage), relationship validation (feature comparison, dependency testing, usage observation).
end

PASS RegularUpdatesWeeklymonthly:
    sutra: "Weekly model/pricing/app updates; monthly primitive extraction, apparatus validation, relationship mapping."
    gloss:
        Weekly (30 min): Monitor OpenAI, Anthropic, Google, Meta releases. Update API pricing from official docs. Review newly used apps (from user feedback/logs). Refresh lifecycle states for deprecated tools. Monthly (2-3 hours): Extract 5-10 new primitives from recently added apps,