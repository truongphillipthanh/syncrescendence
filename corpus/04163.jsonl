{"atom_id": "ATOM-SOURCE-20260216-018-0001", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "To set up a repository for automated code writing and review, establish a loop where a coding agent writes code, the repository enforces risk-aware checks before merging, a code review agent validates the PR, evidence (tests, browser, review) is machine-verifiable, and findings are converted into repeatable harness cases.", "line_start": 18, "line_end": 25, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.4, 0.1, 0.3, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0002", "source_id": "SOURCE-20260216-018", "category": "framework", "content": "A machine-readable contract for code repositories should define risk tiers by path, required checks by tier, documentation drift rules for control-plane changes, and evidence requirements for UI/critical flows.", "line_start": 47, "line_end": 51, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0003", "source_id": "SOURCE-20260216-018", "category": "claim", "content": "Using a single machine-readable contract removes ambiguity and prevents silent drift between scripts, workflow files, and policy documents in a code repository.", "line_start": 79, "line_end": 80, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.4, 0.6, 0.1, 0.2, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0004", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "To optimize CI, run a `risk-policy-gate` first to verify deterministic policy and review-agent state, and only then initiate `test/build/security` fanout jobs, avoiding wasted CI minutes on PRs blocked by policy or unresolved review findings.", "line_start": 83, "line_end": 88, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0005", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "Enforce current-head SHA discipline by treating review state as valid only when it matches the current PR head commit, waiting for the review check run on `headSha`, ignoring stale summary comments, failing if the latest review run is non-success or times out, and requiring reruns after each synchronize/push.", "line_start": 103, "line_end": 110, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.5, 0.1, 0.2, 0.9, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0006", "source_id": "SOURCE-20260216-018", "category": "claim", "content": "Skipping current-head SHA discipline can lead to merging a PR using stale 'clean' evidence.", "line_start": 111, "line_end": 112, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.5, 0.6, 0.1, 0.2, 0.7, 0.8], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0007", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "To prevent duplicate bot comments and race conditions when multiple workflows request reruns, use exactly one workflow as the canonical rerun requester and deduplicate by a marker plus `sha:<head>`.", "line_start": 115, "line_end": 117, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0008", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "Implement an automated remediation loop where, if review findings are actionable, a coding agent reads review context, patches code, runs focused local validation, and pushes a fix commit to the same PR branch, ensuring determinism by pinning the model and effort for reproducibility, skipping stale comments, and never bypassing policy gates.", "line_start": 130, "line_end": 139, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.8, 0.3, 0.1, 0.4, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0009", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "After a clean current-head rerun, auto-resolve unresolved threads where all comments are from the review bot, but never auto-resolve human-participated threads, then rerun the policy gate to reflect the new state of required-conversation-resolution.", "line_start": 142, "line_end": 147, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0010", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "For UI or user-flow changes, require evidence manifests and assertions in CI as first-class proof, ensuring that required flows exist, expected entrypoints and account identities are used, and artifacts are fresh and valid.", "line_start": 150, "line_end": 156, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0011", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "To manage code review agents, use a remediation agent (e.g., Codex Action), a canonical rerun workflow (`greptile-rerun.yml`), a stale-thread cleanup workflow (`greptile-auto-resolve-threads.yml`), and a preflight policy workflow (`risk-policy-gate.yml`).", "line_start": 161, "line_end": 166, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.3, 0.5, 0.1, 0.2, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0012", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "Preserve incident memory and grow long-term coverage by establishing a harness-gap loop where production regressions lead to a harness gap issue, a case is added, and its SLA is tracked.", "line_start": 162, "line_end": 164, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.6, 0.5, 0.1, 0.2, 0.9, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0013", "source_id": "SOURCE-20260216-018", "category": "framework", "content": "Key lessons for running automated code review in PRs include: deterministic ordering (preflight gate before CI fanout), non-negotiable current-head SHA matching, a single canonical writer for review rerun requests, treating vulnerability language and weak-confidence summaries as actionable, auto-resolving bot-only threads only after clean current-head evidence, and using a remediation agent to shorten loop time with strict guardrails.", "line_start": 167, "line_end": 175, "chaperone": {"context_type": "anecdote", "argument_role": "claim", "tension_vector": [0.5, 0.5, 0.1, 0.2, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0014", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "When using a different reviewer for code, maintain the same control-plane semantics and only swap integration points.", "line_start": 167, "line_end": 168, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.2, 0.4, 0.1, 0.1, 0.8, 0.7], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0015", "source_id": "SOURCE-20260216-018", "category": "framework", "content": "A general pattern for automated code review involves a `code review agent`, a `remediation agent`, and a `risk policy gate`, which can be implemented with specific tools like Greptile for code review, Codex Action for remediation, and dedicated workflows for reruns, cleanup, and preflight policies.", "line_start": 178, "line_end": 185, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.4, 0.1, 0.3, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0016", "source_id": "SOURCE-20260216-018", "category": "praxis_hook", "content": "A recommended pattern for managing a repository with agents involves: 1. Combining risk and merge policies into a single contract. 2. Enforcing a preflight gate before expensive CI runs. 3. Requiring a clean code-review-agent state for the current head SHA. 4. Remediating findings in-branch and rerunning deterministically if they exist. 5. Auto-resolving only bot-only stale threads after a clean rerun. 6. Requiring browser evidence for UI/flow changes. 7. Converting incidents into harness cases and tracking loop SLOs.", "line_start": 179, "line_end": 187, "chaperone": {"context_type": "method", "argument_role": "claim", "tension_vector": [0.7, 0.3, 0.1, 0.3, 0.9, 0.6], "opposes_atom_ids": []}, "extensions": {}}
{"atom_id": "ATOM-SOURCE-20260216-018-0017", "source_id": "SOURCE-20260216-018", "category": "claim", "content": "Implementing the recommended pattern for repository management allows agents to implement, validate, and be reviewed with deterministic, auditable standards.", "line_start": 187, "line_end": 187, "chaperone": {"context_type": "consensus", "argument_role": "claim", "tension_vector": [0.6, 0.4, 0.1, 0.2, 0.7, 0.7], "opposes_atom_ids": []}, "extensions": {}}
